<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36" version="26.0.6">
  <diagram name="第 1 页" id="EoKzsfYvX2hHvfft86sc">
    <mxGraphModel dx="4044" dy="2412" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="t9MxABzWcRTLGMJupPC0-1" value="Nacos源码怎么看启动类呢？&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;源码下载下来，没有头绪，那么就可以下载nacos-server.zip，解压之后，bin文件夹下，有启动脚本，查看脚本，可以看到类似 java -jar 的命令，就可以看到哪个是启动包。这里看到的是nacos-server.jar，在包里面的target文件夹下面，进而查看META-INF文件夹下面的MAINFEST.MF文件，可以看到Start-Class的配置项，这个就是启动类。&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;fontStyle=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry y="50" width="590" height="150" as="geometry" />
        </mxCell>
        <mxCell id="t9MxABzWcRTLGMJupPC0-2" value="连接nacos的服务挂掉了之后，nacos客户端上的服务列表不会及时更新，如果客户端用到了这个错误的服务地址怎么办？有重试机制，在rebin、open feign里面有重试的机制。" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;fontStyle=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="690" y="40" width="590" height="150" as="geometry" />
        </mxCell>
        <mxCell id="t9MxABzWcRTLGMJupPC0-3" value="如果没有idea的专业版，构建Spring boot项目，可以用阿里云的脚手架来生成项目：https://start.aliyun.com/&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Spring、Spring Boot、Spring Cloud、Spring Cloud Alibaba之间的关系：&lt;/div&gt;&lt;div&gt;&lt;div&gt;Spring 是基础框架，提供核心的依赖注入和面向切面编程等功能。&lt;/div&gt;&lt;div&gt;Spring Boot 简化了 Spring 应用的开发，通过自动配置和起步依赖等特性，让开发更加快捷。&lt;/div&gt;&lt;div&gt;Spring Cloud 基于 Spring Boot，提供了分布式系统开发的工具集，解决分布式开发中的一系列问题。&lt;/div&gt;&lt;div&gt;Spring Cloud Alibaba 是 Spring Cloud 的实现，提供了阿里巴巴在微服务开发中的一些特色组件和实践，扩展了 Spring Cloud 的能力。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在使用这些框架时，要注意版本的兼容性，不同的 Spring Boot 版本可能需要搭配不同的 Spring Cloud 版本，Spring Cloud Alibaba 也有与之匹配的版本范围。可以通过&amp;nbsp;https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明&amp;nbsp; &amp;nbsp;来查看对应的版本。&lt;/div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;fontStyle=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="1390" y="-110" width="1030" height="330" as="geometry" />
        </mxCell>
        <mxCell id="t9MxABzWcRTLGMJupPC0-4" value="Nacos客户端怎么启动自动注册的？&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;基于Spring boot的自动装配机制。加载&amp;nbsp;spring-cloud-starter-alibaba-nacos-discovery 的jar包，所以里面肯定就有一个spring.factories文件，里面就有自动装配的类，一个一个看，根据类的名称猜测，其中&amp;nbsp;NacosServiceRegistryAutoConfiguration 就是用来注册的自动配置类，自动注入一个&amp;nbsp;NacosAutoServiceRegistration 类，它的构造方法里面，调用了父类&amp;nbsp;AbstractAutoServiceRegistration的构造方法，这个父类，继承了ApplicationListener&amp;lt;WebServerInitializedEvent&amp;gt;，这是spring的监听器，监听了webserver初始化的事件，那么Spring boot在启动的时候就会启动一个webserver，同时发布这个事件，所以就会调用到这个父类的&amp;nbsp;onApplicationEvent 方法，从而调用 bind()----》start()---》register()----》registerInstance()----》registerService()----》reqApi()从而调用http请求服务端的注册接口 /nacos/v1/ns/instance 进行注册。&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;fontStyle=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry y="280" width="650" height="320" as="geometry" />
        </mxCell>
        <mxCell id="t9MxABzWcRTLGMJupPC0-5" value="Nacos服务端怎么接收客户端的注册请求呢？&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;只有在源码里面搜Controller。。。或者客户端源码的调用里面可以看包名信息，是Naming相关的，所以也可以在服务端源码里面去找naming相关的。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;服务端的Controller是REST风格的接口，针对资源来的操作，可以参考！！！&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;fontStyle=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="720" y="280" width="670" height="320" as="geometry" />
        </mxCell>
        <mxCell id="t9MxABzWcRTLGMJupPC0-6" value="&lt;div&gt;&lt;div&gt;&amp;nbsp;/** &lt;font style=&quot;color: rgb(255, 0, 0);&quot;&gt;这就是存服务信息的双重Map ， Service里面还有ClusterMap，Cluster里面的&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;color: rgb(255, 0, 0);&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*&amp;nbsp;ephemeralInstances、persistentInstances 才是真正存 Instance的地方。&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* Map(namespace, Map(group::serviceName, Service)).&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; private final Map&amp;lt;String, Map&amp;lt;String, Service&amp;gt;&amp;gt; serviceMap = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;为什么要设计成双重Map呢？&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;namespace：比如开发环境、测试环境、正式环境，用来做环境隔离。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;group：是用来做业务抽象出来的一层。复杂业务情况下，比如trade这个group，下面有订单、物流、支付等服务。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;cluster：部署地方的区分，比如广州机房、成都机房等。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;这样做就是为了商用高可扩展。如果不需要用，它自己会有一个默认值 Group_Default等。 这些区分也只是逻辑上的，自己可以根据实际情况随意组织，比如公司钱多，一台机器上面值部署一个环境，那么namespace就可以用来做其他的逻辑区分。&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;fontStyle=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="1480" y="280" width="680" height="400" as="geometry" />
        </mxCell>
        <mxCell id="t9MxABzWcRTLGMJupPC0-7" value="Nacos源码里面用到了哪些JUC？&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;1.在putService的时候，用到了synchronized，而且是双检锁。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;2.初始化服务的时候，HealthCheckReactor.scheduleCheck(clientBeatCheckTask); 用到了线程池，并且延迟多少秒执行一次逻辑 （默认5s） ScheduledExecutorService.scheduleWithFixedDelay。&amp;nbsp; 这个跟pr里面初始化检查服务还有点不一样，pr只有几个需要检查的服务，并且正常情况下不需要运行多久，只是简单的http请求，所以简单化用下也行。而这里，很多客户端的连接（N个不同的服务，1个服务可能有N个客户端连接，也就是分布式集群），并且需要长时间运行来监测心跳。说到底，一个是检查心跳连接，一个是检查是否已经启动好。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;ScheduledExecutorService：&lt;br&gt;更适合现代 Java 应用，尤其是在多任务、长时间运行、高并发和需要精确调度的场景。具有更好的线程管理、异常处理和任务控制能力。&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;TimerTask：&lt;br&gt;是早期的定时任务实现，功能相对简单，适用于简单的定时任务，在单线程和不频繁执行的场景中可以使用，但在复杂和长时间运行的任务场景中可能出现问题。&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Nacos源码里面用到了哪些设计模式？&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;fontStyle=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="-830" y="210" width="640" height="1010" as="geometry" />
        </mxCell>
        <mxCell id="t9MxABzWcRTLGMJupPC0-8" value="Nacos客户端发送http请求后，服务端收到后，直接把请求解析成一个实体，丢到阻塞队列里面，然后由线程池来死循环处理队列里面的请求。====异步注册。&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这样异步注册，阿里的并发是很大的，1.x可以坐到13000的并发，所以他们也是为了处理高并发，也是为了客户端启动能快速起来。&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;fontStyle=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="-10" y="680" width="650" height="320" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
