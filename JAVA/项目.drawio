<mxfile host="app.diagrams.net" modified="2024-01-22T03:13:06.599Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" etag="4Ojeg5yNx2IDHOs-ieX2" version="22.1.21" type="github">
  <diagram name="第 1 页" id="1XJYP80JxbJxhC29MnGr">
    <mxGraphModel dx="2358" dy="2159" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="yFXeJq9X8mHxC-HtToIo-2" value="SOLID设计原则" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;fontSize=20;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="1910" y="3841" width="2310" height="1409" as="geometry" />
        </mxCell>
        <mxCell id="axaWvUbI3fm5PjR0QgIP-2" value="分布式缓存：&lt;br&gt;选择Redis作为分布式存储中间件。&lt;br&gt;我们存储的是什么？&lt;br&gt;我们用redis来存储消息ID，当我们需要通知消息的时候，就生成一条记录（id，content）保存到数据库的一张表,content为具体的任务的json串。&lt;br&gt;那为什么我们不存储具体的任务信息？&lt;br&gt;因为考虑到信息安全问题。可能是想防止小pass。以及信息安全吧，最主要的可能是pass的规则问题。那是公司的命根子，不能让实施或者开发轻易拿到，他们现在的方式是存到一个加密的文件，具体怎么加密的，确实不清楚。&lt;br&gt;&lt;br&gt;问题：我们为什么不用消息队列呢？&lt;br&gt;&lt;br&gt;问题：如果我们每个缓存状态更改，都需要通知Redis来广播到每个节点，那么会不会导致服务器压力变大？我们的状态变更还是很频繁的&lt;br&gt;&lt;br&gt;经过讨论，第一版本，是在网关端做负载均衡的配置，同一个ip的所有请求负载到同一个节点上面。这样就不用频繁的进行内存数据的同步了。然后在保存数据库的时候（包括业务本身的数据入库，和缓存消息的入库），再给redis发缓存消息ID&quot;{\&quot;messageid\&quot;,\&#39;xxx\&#39;}&quot;，由redis进行广播，所有的PR分布式节点都进行订阅去同步消息（根据消息ID去数据库里面查询具体的任务信息串）。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="70" y="100" width="840" height="250" as="geometry" />
        </mxCell>
        <mxCell id="axaWvUbI3fm5PjR0QgIP-3" value="分布式数据库：&lt;br&gt;读写分离（主从，没有做主备），历史库。&lt;br&gt;&lt;br&gt;只要有写的方法，都走的是主库。只有查询的都走的是从库。&lt;br&gt;然后历史库，需要前端来配合，需要前端根据页面选择查询的时间来判断走的是不是历史库。然后传值给后端，进行注解的判断？&lt;br&gt;&lt;br&gt;数据库使用的pgsql，可以自己做主从复制，中间件的主从复制一般有2种，1.快照模式。2.增量语句执行。&lt;br&gt;我们公司的pgsql应该用的是WAL（Write-Ahead Logging）来在主服务器和从服务器之间传输事务日志，从而保持从服务器的数据与主服务器的数据同步。&lt;br&gt;&lt;br&gt;在程序里，使用dynamicdatasource来做的主从读写分离。配置多个数据源。然后在每个方法上面加上注解@DS(&quot;slave&quot;)。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="80" y="610" width="800" height="180" as="geometry" />
        </mxCell>
        <mxCell id="lYMavn7DF4E9moOjVgNg-1" value="如果网关层不使用IP负载的模式，那么请求就可能会被打散到所有的pr服务节点上面，那么就必须要求缓存一致性，且强一一致缓存。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1010" y="100" width="320" height="110" as="geometry" />
        </mxCell>
        <mxCell id="lYMavn7DF4E9moOjVgNg-2" value="需要搞清楚java版本的提请审核之后，怎么到药师端提醒有任务的？再来分析下面的需求。&lt;br&gt;&lt;br&gt;我们有一种模式，是分药房模式，可能不同的药师监测不同的药房。那么就会有子任务出现。由不同的药师来进行审核。那如果用同一IP的请求到同一个服务器。那么" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="980" y="250" width="320" height="110" as="geometry" />
        </mxCell>
        <mxCell id="lYMavn7DF4E9moOjVgNg-3" value="公司整个PASS项目是一个微服务项目。&lt;br&gt;&lt;br&gt;PR作为其中的一个微服务。&lt;br&gt;&lt;br&gt;我们做的是集群。分担医生站来的请求压力。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="290" y="-30" width="320" height="110" as="geometry" />
        </mxCell>
        <mxCell id="lYMavn7DF4E9moOjVgNg-4" value="由于reids的广播消息不算很靠谱的，那我们要怎么保证各个节点的内存数据同步呢？&lt;br&gt;&lt;br&gt;跑定时任务？每个缓存对象（caseid对应的一个任务）查看其中的时间戳，是不是跟数据库的能对应上。如果不能则更新最新的数据到未成功同步的节点？那么是否会导致效率的问题呢？&lt;br&gt;&lt;br&gt;方案2：每个PR后端节点链接redis的时候，都在redis里面存上各自的ip？有什么用呢？&lt;br&gt;&lt;br&gt;因为我们缓存只存消息ID，所以不管是同步消息，还是定时任务去查缓存不一致，都需要查询数据库，这样会不会导致数据库崩掉？？" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="150" y="380" width="620" height="180" as="geometry" />
        </mxCell>
        <mxCell id="azIFYM6eBztKxtA_MHt6-1" value="性能优化：&lt;br&gt;用jmiter做压测，我们.net版本的 门诊80，住院120，加起来就是200。应该说的是QPS？&lt;br&gt;java版本的性能要差点。首次排查可能是因为Disruptor的线程引起的，生产者线程1个，然后消费者线程N个。还未排查出是不是这个问题。&lt;br&gt;&lt;br&gt;&lt;br&gt;bs优化：&lt;br&gt;首先后端逻辑很多+=，改成StringBuilder。&lt;br&gt;然后页面优化（重点）：因为业务需求原因，我们需要在页面存储2个大的JSON串。还有就是JS文件，刚开始也是跟html写到一起的，大概有几千行JS代码，且里面有需要thymleaf解析的代码。&lt;br&gt;解决步骤：大的JSOn串缓存在后端，根据taskid来进行缓存，当页面加载完成之后，再ajax同步从后端缓存取，取完就删除，这样也不会占用内存。&lt;br&gt;同时，把JS分离开到单独的文件。需要后端在JS解析的代码，修改成Js变量。这样不用解析。&lt;br&gt;改完之后，完全能撑住200并发了。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="90" y="910" width="810" height="230" as="geometry" />
        </mxCell>
        <mxCell id="OiV16W11Bcy6xy-m6XNg-1" value="要搞清楚.net版本和java版本统计分析和查询的逻辑，从开始的查询和统计分析进行硬查询，到进行预处理查询，再到进行优化。&lt;br&gt;&lt;br&gt;.net版本的统计分析痛点：预处理到表里面的是具体的count，比如预处理表的字段：提交数-10，干预数-20，双签数-30等等，而点击链接是进行代码逻辑硬查询（虽然也是查询预处理表，但是指标逻辑是可以跟随需求而变动的），但是预处理到表里面的历史数据，count是不能改变的，就导致了count跟实际链接查询出来的数据不一致。解决办法就要进行刷历史数据，这个过程比较耗时。&lt;br&gt;&lt;br&gt;java版本解决了这个痛点，首先预处理到表里面的不在是count，而是一个标记，比如：auditmodeid&amp;nbsp; 提交数-1 干预数-0，当查询详情的时候，根据只需要判断&amp;gt;0即可。这样能跟整个统计出来的数字对应上。但是这种情况虽然对应上了，如果指标算法变了的话（具体怎么变化？），那么历史数据的count跟变了之后想要的count是对不上的。但是这个就容错高些了。看医院需不需要统一，如果需要就刷历史数据。主动权给到医院。有的医院不需要刷，有的可能需要。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="980" y="440" width="460" height="250" as="geometry" />
        </mxCell>
        <mxCell id="0i6LU9kepRgSpGDFbb0o-1" value="公共的逻辑可以放哪里，会变化的逻辑放哪里，怎么进行封装，可以看看AQS源码，Spring源码，Tomcat源码" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="750" y="-110" width="300" height="60" as="geometry" />
        </mxCell>
        <mxCell id="M4xeJUEj8VqUzHAWt1Ij-1" value="Redis，PR用的是hash存储。对象通过序列化，反序列化的方式进行存储。&lt;br&gt;类里面的方法不能以is开头，否则反序列化会报错，当然这根序列化器有关系，可以自定义吧？" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="690" y="-10" width="300" height="80" as="geometry" />
        </mxCell>
        <mxCell id="pnb352GZgsO-i2-xDFfo-1" value="可以吧PR的任务生成，加上一个抢单的功能！！！&lt;br&gt;&lt;br&gt;分布式环境下的！！！！&lt;br&gt;&lt;br&gt;redis可以用reddison来做分布式锁的框架！" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="340" y="-180" width="310" height="90" as="geometry" />
        </mxCell>
        <mxCell id="GLIDyd0n-ON3j2NHpdD_-1" value="Disruptor，在高并发下面报错：&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2023-12-14 09:26:15[disruptor-3]ERROR c.m.m d.h. DatalWrapperEventHandler - workHandler-3解析队列数据对象 保存病人药品医嘱信息-&amp;gt;null&lt;br&gt;java.lang.NullPointerException: null&lt;br&gt;&amp;nbsp;at com.medicom.modules.disruptor.handler.DatawrapperEventHandler.onEvent(DatawrapperEventHandler.java:40)&lt;br&gt;&amp;nbsp;at com.medicom.modules.disruptor.handler.DataWrapperEventHandler.onEvent (DatawrapperEventHandler.java:18)&lt;br&gt;at com.lmax.disruptor.workProcessor.run (WorkProcessor.java:143)&lt;br&gt;&lt;br&gt;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)&lt;br&gt;at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)&lt;br&gt;at java.lang.Thread.run (Thread.java : 748)&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;EnCache，在高并发下面报错：&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;存放encache+类有继承关系，类需要实现Serialzable接口，且在子类上需要加上@EqualsAndHashCode(callSuper=true)，防止从磁盘里面读取进行反序列化时父类为null。&amp;nbsp;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1140" y="-350" width="670" height="390" as="geometry" />
        </mxCell>
        <mxCell id="GLIDyd0n-ON3j2NHpdD_-2" value="表分区，分区到不同磁盘？好处是什么？" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="720" y="-270" width="300" height="60" as="geometry" />
        </mxCell>
        <mxCell id="52weYLeMf9iYNcdraF4N-1" value="&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;，优化性能，发现很多类的转换，开始用的&lt;/font&gt;BeanUtil.toBean，这种是通过反射的方式来得到转换后的对象，&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;高并发下测试比较耗费性能。每个响应多耗时400ms,并发数少20个。&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;ClinicMainTaskInfo entity = BeanUtil.toBean(bean, PrClassUtils.CLINIC_MAIN_TASK_INFO);&lt;/font&gt;&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;pre style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;ClinicMainTaskInfo entity = TaskInfoMainBeanConvert.INSTANCE.convertToClinicMainTaskInfo(bean);&lt;/font&gt;&lt;/pre&gt;&lt;/pre&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1890" y="-310" width="900" height="350" as="geometry" />
        </mxCell>
        <mxCell id="52weYLeMf9iYNcdraF4N-2" value="&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;JetBrains Mono&#39;,monospace;font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;import &lt;/span&gt;org.mapstruct.&lt;span style=&quot;color:#bbb529;&quot;&gt;Mapper&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;import &lt;/span&gt;org.mapstruct.factory.Mappers&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@ClassName: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;TaskInfoMainBeanConvert&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Description: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;转换主任务对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Author: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Date: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Version: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;V1.0&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Mapper&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public interface &lt;/span&gt;TaskInfoMainBeanConvert {&lt;br&gt;    TaskInfoMainBeanConvert &lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;INSTANCE &lt;/span&gt;= Mappers.&lt;span style=&quot;font-style:italic;&quot;&gt;getMapper&lt;/span&gt;(TaskInfoMainBeanConvert.&lt;span style=&quot;color:#cc7832;&quot;&gt;class&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@param &lt;/span&gt;&lt;span style=&quot;color:#8a653b;font-style:italic;&quot;&gt;bean &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;待转化对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;     &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@return &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Description &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;     &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Author &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Date &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;TaskInfoMainBean &lt;span style=&quot;color:#ffc66d;&quot;&gt;convertToTaskInfoMainBean&lt;/span&gt;(TaskInfoMainBean bean)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@param &lt;/span&gt;&lt;span style=&quot;color:#8a653b;font-style:italic;&quot;&gt;bean &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;待转化对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;     &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@return &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;ClinicMainTaskInfo&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Description &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;     &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Author&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;ClinicMainTaskInfo &lt;span style=&quot;color:#ffc66d;&quot;&gt;convertToClinicMainTaskInfo&lt;/span&gt;(TaskInfoMainBean bean)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;InHospMainTaskInfo &lt;span style=&quot;color:#ffc66d;&quot;&gt;convertToInHospMainTaskInfo&lt;/span&gt;(TaskInfoMainBean bean)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;InterMainTaskInfo &lt;span style=&quot;color:#ffc66d;&quot;&gt;convertToInterMainTaskInfo&lt;/span&gt;(TaskInfoMainBean bean)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;br&gt;&lt;/pre&gt;&lt;/pre&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="2895" y="-330" width="745" height="880" as="geometry" />
        </mxCell>
        <mxCell id="CAA8TabalaVCixUhrOd4-1" value="可以回退到12月份代码进行性能测试。" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="2160" y="-410" width="290" height="80" as="geometry" />
        </mxCell>
        <mxCell id="4FLja5BOqqyU_yTpesLY-1" value="IM，有一个问题，超过6个页面嵌套之后，会导致浏览器请求卡死。&lt;br&gt;&lt;p&gt;浏览器对同一个域名下并行连接数有限制，这一限制通常被称为&quot;并发连接数&quot;。这是因为浏览器为了避免过多的并发请求对网络性能造成负面影响，对同一个域名下的并发连接数进行了限制。&lt;/p&gt;&lt;p&gt;通常，对于 HTTP/1.1 协议，浏览器对同一域名下的并发连接数限制为 6-8 个&lt;/p&gt;&lt;p&gt;具体原因：因为要兼容IE6，所以不能使用WebSocket的方式，使用的是comet方式通信&lt;/p&gt;&lt;p&gt;Comet 是一种通过持续连接（long-polling 或 streaming）实现服务器推送数据到客户端的通信方式，以实现实时更新的目的。这种通信方式主要应用于需要实时性的网络应用，比如聊天应用、实时消息推送等。&lt;br&gt;&lt;/p&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Long Polling（长轮询）：&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;在长轮询中，客户端向服务器发送一个请求，并保持该请求处于挂起状态，直到服务器有新的数据可用或超时为止。&lt;/li&gt;&lt;li&gt;服务器在有新数据可用时，立即将数据发送给客户端，并关闭连接。&lt;/li&gt;&lt;li&gt;客户端在收到数据后，立即发起下一个请求，保持连接处于持续状态。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Streaming（流式传输）：&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;在流式传输中，客户端与服务器建立一条持久连接，服务器可以在任何时候向客户端发送数据。&lt;/li&gt;&lt;li&gt;服务器将数据以流的形式发送给客户端，客户端可以实时接收并处理这些数据。&lt;/li&gt;&lt;li&gt;这种方式相比长轮询来说，更加实时，因为在有新数据时，服务器可以立即将其推送给客户端。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;Comet 方式通信的优点包括实时性强、无需频繁的轮询请求、降低了延迟等。然而，也存在一些缺点，如较高的服务器资源占用、可能会受到浏览器连接数限制等。&lt;/p&gt;&lt;p&gt;在现代的 Web 开发中，WebSocket 技术逐渐成为了一种更为高效的实时通信方式，因为它提供了双向通信的能力，而不需要像 Comet 那样通过多次 HTTP 请求。WebSocket 允许服务器主动向客户端推送消息，同时保持低延迟和更高的效率。&lt;/p&gt;&lt;/li&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="30" y="-820" width="600" height="570" as="geometry" />
        </mxCell>
        <mxCell id="K7jlHJTKLegIbDve6_yx-1" value="序列化问题：&lt;br&gt;序列化主要用于：1.类的网络传输（需要弄成二进制）。2.类的持久化。&lt;br&gt;&lt;br&gt;1.使用java中的Serializable接口：效率慢，占用空间大，无法跨语言。&lt;br&gt;&lt;br&gt;2.使用其它框架，怎么选型？&lt;br&gt;&amp;nbsp;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;是否需要跨语言支持。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;空间：编码后的空间占用&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;时间：编码所需的时间&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;是否追求可读性。（Json具有可读性，二进制没有）&lt;br&gt;&lt;br&gt;&lt;br&gt;如果是应用层，一般选择序列化成Json进行持久化或者网络传输，Json是跨语言的，并且可读性高。&lt;br&gt;&lt;br&gt;如果是用作RPC、分布式节点间通信，可选择Json，也可选择高效率的二进制序列化。" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="850" y="-890" width="660" height="410" as="geometry" />
        </mxCell>
        <mxCell id="FtiWQNE3cC4o1lRVwpFo-1" value="面向对象3大特性：&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;封装：封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类&lt;span style=&quot;background-color: initial;&quot;&gt;提供的方式来访问内部信息或者数据。&lt;/span&gt;封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。易用就是不关系具体方法里面的实现。&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; 抽象：&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;继承：主要解决代码复用问题。&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;多态：之类可以替换父类，运行时执行子类的代码。需要变成语言的语法支持。提高代码的可扩展性和复用性。&lt;br&gt;&lt;br&gt;&lt;br&gt;面向过程和面向对象的区别？&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。&lt;br&gt;&lt;br&gt;面向对象的优势：&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;1.能够应对大型复杂的项目开发。进行业务建模，将需求翻译成类，思考类之间的交互关系，然后再处理业务流程，组装成程序。面向过程也可以写出面向对象的代码！&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.面向对象风格的代码更易复用、易扩展、易维护。&lt;br&gt;&lt;br&gt;&lt;br&gt;自己平时写的代码，自认为是面向对象的，其实是面向过程的。。。。并不是把所有的东西都糅到1个类里面就算是面向对象了。&lt;br&gt;&lt;br&gt;哪些代码设计看似是面向对象，其实是面向过程？&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;1.滥用getter、setter。或者@Data：违反了封装的特性，如右边所示。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;定义类属性时，尽量不定义setter方法（@Getter），同时getter方法也要注意集合内部元素被修改。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.滥用全局变量和全局方法：各种静态工具类，静态常量类，&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;喜欢所有的东西都放在一个静态常量类里面：可维护性低、代码编译时间长、复用性低。应该根据业务分成多个静态常量类，或者把常量定义在相关的类里面。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;3.定义数据和方法分离的类：基本每天都在写，mvc模式，定义的vo、bo、entity基本都是，只定义数据，不定义方法，都是在业务层操作这些数据。这也是贫血模型。典型的面向过程开发风格。&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;全局变量是一种面向过程的编程风格，有种种弊端。实际上，滥用全局变量&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;也让编写单元测试变得困难。&lt;/span&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="110" y="1420" width="1060" height="860" as="geometry" />
        </mxCell>
        <mxCell id="FN0yQ43i4ETcDHctbkBb-1" value="&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;JetBrains Mono&#39;,monospace;font-size:12.0pt;&quot;&gt;&lt;pre style=&quot;font-family: &amp;quot;JetBrains Mono&amp;quot;, monospace; font-size: 12pt;&quot;&gt;import lombok.&lt;span style=&quot;color:#bbb529;&quot;&gt;Data&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;import &lt;/span&gt;java.util.Collections&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;import &lt;/span&gt;java.util.List&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@ClassName: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;OOPClass&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Description: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;这就是我们平时用的类定义，其实就是面向过程的风格，跟定义成&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;其实没区别了，这里面存在一些问题：&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* 1.totalAccount&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;的值可能跟&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;accountName&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;的实际数量不一致。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* 2.totalMoney&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;应该是私有的数据，根据面向对象的封装特性，应该额外提供方法来给外界调用（&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;increaseTotalMoney(),decreaseTotalMoney()&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;），&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;在方法里面还可以做一些额外的逻辑判断，比如权限等等。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* 3.accountName&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;这个集合值，首先不应该提供&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;setter&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;方法，其次，提供&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;getter&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;方法之后，外界拿到了之后可能对其进行修改，或者&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;clear()&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;，很危险。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;那这时可以改成&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;Collections.unmodifiableList()&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;，改了之后，还有个问题，外界拿到集合之后，如果元素是对象，修改对象的某个属性怎么办？&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Author: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;xiahaitao&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Date: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;2024/1/16 11:01&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Version: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;V1.0&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Data&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public class &lt;/span&gt;OOPClass {&lt;br&gt;    &lt;span style=&quot;color:#cc7832;&quot;&gt;private &lt;/span&gt;String &lt;span style=&quot;color:#9876aa;&quot;&gt;name&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    private int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;age&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    private &lt;/span&gt;List&amp;lt;String&amp;gt; &lt;span style=&quot;color:#9876aa;&quot;&gt;accountName&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//    private List&amp;lt;String&amp;gt; getAccountName(){&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//        return Collections.unmodifiableList(accountName);&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//    }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;totalAccount&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    private int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;totalMoney&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;br&gt;&lt;/pre&gt;&lt;/pre&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1260" y="1600" width="1100" height="580" as="geometry" />
        </mxCell>
        <mxCell id="FN0yQ43i4ETcDHctbkBb-3" value="接口和抽象类：&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;抽象类：1. 不能被实例化，只能被继承。可以有属性和方法，方法可以不包含实现（抽象方法）。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.子类继承抽象类，必须实现所有的抽象方法。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&amp;nbsp; &amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;is a 的关系。多是为了解决代码复用的问题。 典型的用法，模板设计模式。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;接口：不能包含属性，只能声明方法，不能有实现。类实现接口，必须实现接口中所有的方法。 has a 的关系，表示具有某一组行为特性，解决的是解耦问题，隔离接口和具体的实现，提高扩展性。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;基于接口而非实现编程（基于抽象而非实现编程，代码里面体现在，不要手动new对象，用接口进行依赖注入，这样好进行扩展，好进行单元测试&lt;/font&gt;）：一定&lt;span style=&quot;background-color: initial;&quot;&gt;要有抽象意识、封装意识、接口意识。越抽象越顶层、越脱离具体某一实现的设计，越能&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;提高代码的灵活性、扩展性、可维护性。&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;1.函数的命名不能暴露任何细节。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.封装具体的细节。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;3.为实现类定义抽象的接口。&lt;br&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;IUpload&amp;nbsp; upload = new AliYunUpLoad();&amp;nbsp; 这里是new出来具体的实现类，那么如果需要换一种上传方式，就需要改代码了，有没有好的方式？" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="120" y="2290" width="1070" height="440" as="geometry" />
        </mxCell>
        <mxCell id="J9Vd1cQ4T2tUTU1RXiHH-1" value="&lt;div&gt;组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;继承层次过深、过复杂，也会影响到代码的可维护性，继承爆炸。&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;可以利用组合（composition）、接口、委托（delegation）三个技术手&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;段，一块儿来解决继承存在的问题。&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;组合：将对象组装在一起以创建更复杂对象的方式（将类实例化到另外一个类里面）。&amp;nbsp; &amp;nbsp; 委托：将某个对象的责任委托给另一个对象的机制。&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;Spring的依赖注入跟这个有没有关联？&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;Entity、BO、VO 三者之间的代码有很大重复，但又不完全相同。我们该如&lt;span style=&quot;background-color: initial;&quot;&gt;何处理 Entity、BO、VO 代码重复的问题呢？&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1250" y="2320" width="1030" height="270" as="geometry" />
        </mxCell>
        <mxCell id="J9Vd1cQ4T2tUTU1RXiHH-2" value="把PR里面的TaskInfo改造成面向对象，并且从单纯的继承改造成组合。" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=18;" parent="1" vertex="1">
          <mxGeometry x="1290" y="2240" width="740" height="60" as="geometry" />
        </mxCell>
        <mxCell id="J9Vd1cQ4T2tUTU1RXiHH-3" value="&lt;div&gt;贫血模型、充血模型（DDD）：&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;我们几乎所有的项目都是贫血模型，基于面向过程开发，每个类里面基本只有字段，将数据与业务逻辑操作进行分离，背离了面向对象的封装特性。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;DDD充血模型，则相反，将数据与业务逻辑封装到一个类里面，符合了面向对象编程风格。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;DDD实现的代码，也是基于三层架构，Controller层、Repository层都不变，变化的只是Service层。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;为什么我们都喜欢用贫血模型进行面向过程开发？&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;业务简单。设计简单，充血模型设计困难。学习成本。&amp;nbsp; &amp;nbsp;DDD充血模型适合业务复杂、稳定的项目。&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1250" y="2620" width="1030" height="270" as="geometry" />
        </mxCell>
        <mxCell id="tLVYLYFxv8BBkOP2GH6Q-1" value="&lt;div&gt;利用DDD开发一个钱包功能：自己看文档！！！&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在基于充血模型的 DDD 开发模式中，将业务逻辑移动到Domain 中，Service 类变得很薄，但在我们的代码设计与实现中，并没有完全将Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;1.Service 类负责与 Repository 交流。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.Service 类负责跨领域模型的业务聚合功能。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;3.Service 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消&lt;span style=&quot;background-color: initial;&quot;&gt;息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;没必要！业务逻辑比较简单，或者不需要逻辑比如Vo对象，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我对DDD的看法就是，它可以把原来最重的service逻辑拆分并且转移一部分逻辑，可以使得代码可读性略微提高，另一个比较重要的点是使得模型充血以后，基于模型的业务抽象在不断的迭代之后会越来越明确，业务的细节会越来越精准，通过阅读模型的充血行为代码，能够极快的了解系统的业务，对于开发来说能说明显的提升开发效率。&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1250" y="2910" width="1080" height="510" as="geometry" />
        </mxCell>
        <mxCell id="tLVYLYFxv8BBkOP2GH6Q-2" value="&lt;div&gt;面向对象分析（OOA，需求分析）、面向对象设计（OOD，设计各种类）、面向对象编程（OOP），是面向对象开发的三个主要环节。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;“为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。”&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;分析：1.appid+秘钥鉴权(给调用方)，这种秘钥容易被截获。2.appid+加密后的秘钥，也容易被截获，重放攻击。3.传参appid+秘钥+时间戳+由前面几个参数生成的token，后端解析token，验证时间戳是否在有效范围内。虽然也会被重放攻击，但是有时间范围。增大攻击的难度。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如何做需求分析，如何做职责划分？需要定义哪些类？每个类应该具有哪些属性、方法？类与类之间该如何交互？如何组装类成一个可执行的程序？&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;划分职责而进一步识别出有哪些类、定义类及其属性和方法、定义类与类之间的交互关系、将类组装起来并提供执行入口。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;根据需求描述，把其中涉及的功能点，一个一个罗列出来，要分的很细很细！！！，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。（建议用这个识别出有哪些类）&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;1.将url、appid、秘钥、时间戳拼成字符串。&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;2.SHA加密算法加密字符串成一个token。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;3.拼接url。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;4.后端解析url。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;5.后端拿到appid对应的秘钥等信息。（这里可以从redis、mysql等地方拿，设计成接口合适）&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;6.根据时间戳判断token是否过期。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;7.验证token是否相等。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4两个操作；CredentialStorage 负责 5 这个操作。（具体的定义看文档）&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;针对这种复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;对于方法的识别，很多面向对象相关的书籍，一般都是这么讲的，识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。&lt;br&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;将类组装起来，提供执行入口：Main函数或者提供api给外部。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;所以这里还是抽象出一个接口，给外部提供方法使用：ApiAuthencator接口。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;br&gt;&lt;br&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="60" y="2820" width="1170" height="900" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-1" value="类之间有哪些关系：&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;泛化（继承）、实现（接口实现）、关联（作为成员变量用到了另外的类）、聚合、组合、依赖（方法参数或者返回值用到了另外的类）。 &lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;其中聚合、组合、关联，统一可以看做是组合，作为成员变量用到了另外的类。&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1270" y="3450" width="1030" height="140" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-2" value="设计原则：&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;SOLID、KISS、YAGNI、DRY、LOD&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;SOLID：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单一职责原则（Single Responsibility Principle）：&lt;/strong&gt; 一个类应该只有一个引起变化的原因，即一个类应该只有一个职责。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;开放/封闭原则（Open/Closed Principle）：&lt;/strong&gt; 软件实体（类、模块、函数等）应该对扩展是开放的，但对修改是封闭的。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;里氏替换原则（Liskov Substitution Principle）：&lt;/strong&gt; 子类型必须能够替换掉它们的基类型。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;接口隔离原则（Interface Segregation Principle）：&lt;/strong&gt; 一个类不应该被强迫实现它不需要使用的接口。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;依赖反转原则（Dependency Inversion Principle）：&lt;/strong&gt; 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于具体实现，而具体实现应该依赖于抽象。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;KISS：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;保持简单原则（Keep It Simple, Stupid）：&lt;/strong&gt; 程序应该保持简单，易于理解和维护。过度的复杂性往往会导致不必要的问题。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;YAGNI：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;你不需要它原则（You Aren&#39;t Gonna Need It）：&lt;/strong&gt; 在实际需要之前，不要添加不必要的功能。避免过度设计和过早优化。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;DRY：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不要重复自己原则（Don&#39;t Repeat Yourself）：&lt;/strong&gt; 程序中的每一块知识都应该有一个明确、清晰、不可亵渎的单一表示。避免代码重复，使用抽象和模块化。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;LOD：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;迪米特法则（Law of Demeter）：&lt;/strong&gt; 一个对象应该对其他对象有最少的了解。一个类应该对自己需要调用的方法知之甚少，尽量降低类之间的耦合度。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="60" y="3790" width="1460" height="600" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-3" value="支持达梦数据库、OceanBase数据库。&lt;br&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="700" y="-390" width="300" height="60" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-4" value="&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;单一职责原则（Single Responsibility Principle）&lt;br&gt;&lt;/strong&gt;&lt;div&gt;一个类的代码行数最好不能超过 200 行，函数&lt;span style=&quot;background-color: initial;&quot;&gt;个数及属性个数都最好不要超过 10 个。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。&lt;br&gt;&lt;br&gt;类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；&lt;br&gt;&lt;br&gt;&lt;div&gt;类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，&lt;span style=&quot;background-color: initial;&quot;&gt;我们就需要考虑对类进行拆分；&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供&lt;span style=&quot;background-color: initial;&quot;&gt;更多的类使用，从而提高代码的复用性；&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的&lt;span style=&quot;background-color: initial;&quot;&gt;Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半&lt;span style=&quot;background-color: initial;&quot;&gt;的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="2000" y="3901" width="1040" height="390" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-5" value="&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;开放/封闭原则（Open/Closed Principle）&lt;br&gt;&lt;/strong&gt;因为需求有增加，需要对原来的类方法做修改（参数的添加、里面逻辑的增加或修改）。这意味着调用&lt;span style=&quot;background-color: initial;&quot;&gt;这个接口的代码都要做相应的修改。&lt;/span&gt;相应的单元测试都需&lt;span style=&quot;background-color: initial;&quot;&gt;要修改。&lt;/span&gt;这种是基于“修改”的方式来实现新功能。那怎么用扩展来实现新功能呢？&lt;br&gt;&lt;br&gt;&lt;br&gt;1.将方法的参数封装成1个类。&lt;br&gt;2.引入handler的概念，把if判断逻辑分散在各个handler中。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，&lt;span style=&quot;background-color: initial;&quot;&gt;这个是做不到的。只要它没有破坏原有的代码的正常运&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。&lt;/span&gt;我们要做的是尽量让修改操作更集中、更少、更上&lt;span style=&quot;background-color: initial;&quot;&gt;层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;为了尽量写出扩展性好&lt;span style=&quot;background-color: initial;&quot;&gt;的代码，我们要时刻具备扩展意识、抽象意识、封装意识。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;23 种经典设计模式，大部分都是&lt;span style=&quot;background-color: initial;&quot;&gt;为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;最常用来提高代码扩展性的方法有：多态、依赖注入、&lt;span style=&quot;background-color: initial;&quot;&gt;基于接口而非实现编程，以及大部分的设计模式。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是&lt;span style=&quot;background-color: initial;&quot;&gt;为了让系统更有弹性！&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="2000" y="4341" width="1040" height="430" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-6" value="&lt;div&gt;&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;里氏替换原则（Liskov Substitution Principle）:&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;&lt;br&gt;&lt;/strong&gt;&lt;/div&gt;子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。&amp;nbsp;&lt;br&gt;&lt;br&gt;&lt;div&gt;&lt;b&gt;咋一看，跟多态的概念有点像，实际上是2种不一样的东西！！！！！！它们的关注角度是不一样的，多态是语言的一种和编译器支持的一种语法。里氏替换关注的是子类如何进行设计，保证逻辑的正确性（跟父类的行为一样）！&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;子类在设计的时候，要遵守父类的行为约定（或者&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;也可以替换成接口和实现类之间的关系。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;理解里式替换原则，最&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;包括注释中所罗列的任何特殊说明。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;哪些是破坏了里氏替换原则？&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;1.父类方法返回集合，排序按照A字段，子类相同方法返回集合，排序却是按照B字段。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.返回值，一个返回null，一个返回new 对象。等等。。。。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;里氏替换的意义：&lt;/div&gt;&lt;div&gt;一、改进已有实现。例如程序最开始实现时采用了低效的排序算法，改进时使用LSP实现更高效的排序算法。&lt;br&gt;&lt;/div&gt;&lt;div&gt; 二、指导程序开发。告诉我们如何组织类和子类（subtype），子类的方法（非私有方法）要符合约定。&lt;br&gt;&lt;/div&gt;&lt;div&gt; 三、改进抽象设计。如果一个子类中的实现违反了LSP，那么是不是考虑抽象或者设计出了问题。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt; 多态是一种能力，而里氏替换原则一种约定，想要实现这种约定，需要依靠多态这种能力。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;里氏替换最终一句话还是对扩展开放，对修改关闭，不能改变父类的入参，返回，但是子&lt;span style=&quot;color: rgb(76, 76, 76); font-family: 微软雅黑; font-size: 12.0056pt; background-color: initial;&quot;&gt;类可以自己扩展方法中的逻辑。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="3090" y="3901" width="1070" height="660" as="geometry" />
        </mxCell>
        <mxCell id="Vjz6WrMUGAyvdLdzKQWN-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;怎么有种感觉，一切的原则都是给开放封闭原则铺路呢&lt;/font&gt;" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="1650" y="3650" width="500" height="100" as="geometry" />
        </mxCell>
        <mxCell id="Vjz6WrMUGAyvdLdzKQWN-2" value="&lt;div&gt;&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;接口隔离原则（Interface Segregation Principle）&lt;/strong&gt;&lt;br&gt;&lt;/div&gt;&amp;nbsp;一个类不应该被强迫实现它不需要使用的接口。&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;把&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;“&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;”&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;理解为一组&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt; API &lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口集合：&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;在设计微服务或者类库接口的时候，如果部&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7551pt; background-color: initial;&quot;&gt;分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;mso-spacerun:&#39;yes&#39;;font-size:12.7551pt;font-family:微软雅黑;color:rgb(53,53,53);&quot;&gt;用，而不是强迫其他调用者也依赖这部分不会被用到的接口。&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;mso-spacerun:&#39;yes&#39;;font-size:12.7551pt;font-family:微软雅黑;color:rgb(53,53,53);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;把&lt;span style=&quot;font-size: 15.006pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;“&lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口&lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;”&lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;理解为单个&lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt; API &lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口或函数：&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;函数的设计要功能单一，不要将多个不同的&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;功能逻辑在一个函数中实现。（这个看起来跟单一职责原则有点像呢）&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;部分功能，那接口的设计就不够职责单一。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;把&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;“&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;”&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;理解为&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt; OOP &lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;中的接口概念：&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;理解成java中的interface。&lt;/div&gt;&lt;div&gt;接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="3090" y="4601" width="1040" height="430" as="geometry" />
        </mxCell>
        <mxCell id="yFXeJq9X8mHxC-HtToIo-1" value="&lt;div&gt;&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;依赖反转原则（Dependency Inversion Principle）：&lt;/strong&gt;&lt;/div&gt;高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于具体实现，而具体实现应该依赖于抽象&lt;div&gt;&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;&lt;br&gt;&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;控制反转、依赖注入、依赖反转的区别：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;控制反转：是一个比较笼统的设计思想。传统的程序中，程序员编写主要的控制逻辑，调用框架或库中提供的方法。而在控制反转中，程序的主控制流程被反转了，由框架或容器负责调用程序员编写的代码。比如创建对象，普通的是我们自己手动new，完全可以交给框架。&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;依赖注入：是一种具体的编码技巧。&lt;/span&gt;不通过 new() 的方式在类内部创建&lt;span style=&quot;background-color: initial;&quot;&gt;依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;（或注入）给类使用。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;依赖注入框架：&lt;/span&gt;我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关&lt;span style=&quot;background-color: initial;&quot;&gt;系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;来做的事情&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;依赖倒置原则：&lt;/span&gt;Tomcat 和应用程序代码之间并没&lt;span style=&quot;background-color: initial;&quot;&gt;有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Sevlet 规范。Servlet 规范不依&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;规范。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="2000" y="4810" width="1040" height="430" as="geometry" />
        </mxCell>
        <mxCell id="yFXeJq9X8mHxC-HtToIo-3" value="&lt;div&gt;&lt;div&gt;&lt;b&gt;YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的&lt;/b&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前&lt;/b&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;不需要的就不要做）。&lt;/b&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;KISS原则实践：&lt;/b&gt;&lt;/div&gt;&lt;b&gt;不要使用同事可能不懂的技术来实现代码；不要重复造轮子，要善于使用已经有的工具类库；不要过度优化。&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;DRY：不要重复自己原则，&lt;/b&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;实现逻辑重复、功能语义重复、代码执行重复。实现逻&lt;/b&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重&lt;/b&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。&lt;br&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;如何做到代码复用性：&lt;/b&gt;&lt;br&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;减少代码耦合&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;满足单一职责原则&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;模块化&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;业务与非业务逻辑分离&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;通用代码下沉&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;继承、多态、抽象、封装&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;应用模板等设计模式&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="260" y="4530" width="1040" height="430" as="geometry" />
        </mxCell>
        <mxCell id="yFXeJq9X8mHxC-HtToIo-4" value="&lt;div&gt;&lt;div&gt;&lt;b&gt;LOD 迪米特法则：&lt;/b&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;一个对象应该对其他对象有最少的了解。一个类应该对自己需要调用的方法知之甚少，尽量降低类之间的耦合度。&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;高内聚、低耦合：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接&lt;span style=&quot;background-color: initial;&quot;&gt;口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;他部分。一旦发生变化，需要了解这一变化的类就会比较少。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;目的都是实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出&lt;span style=&quot;background-color: initial;&quot;&gt;发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归。&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="240" y="5220" width="1040" height="430" as="geometry" />
        </mxCell>
        <mxCell id="yFXeJq9X8mHxC-HtToIo-5" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;设计思想有哪些，跟设计原则的关系是什么？&lt;/font&gt;" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="327" y="5040" width="500" height="100" as="geometry" />
        </mxCell>
        <mxCell id="yFXeJq9X8mHxC-HtToIo-6" value="PR的流程可否改造成类似netty的pipeline的方式？弄成1个1个的handler？" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1650" y="-585" width="300" height="60" as="geometry" />
        </mxCell>
        <mxCell id="vVBWxAJ4765AQ51cDCxZ-1" value="&lt;div style=&quot;&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;做业务系统的分析和设计：（这里的这个案例有点像微服务的DDD设计了）&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;积分系统的设计，抽象出来底层模块，积分模块，只负责用户积分的修改和积分的历史纪录查询。然后积分规则抽象出来一个营销模块，放里面。同时还有1个订单模块。当发生订单之后，订单异步方式调用营销系统，营销模块拿到订单信息，查询订单积分兑换规则，计算积分数量，最后营销模块调用底层的积分模块，进行修改，并增加历史记录。&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;1.合理的将功能划分到不同模块：&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;模块设计，跟之前的类设计是基本一样的：&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;明模块划分的不够合理，职责不够清晰，耦合过于严重。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;接受上层系统包含下层系统的业务信息。 这个有点类似迪米特法则。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;2.设计模块与模块之间的交互关系：&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;步调用。第一种方式简单直接，第二种方式的解耦效果更好。&amp;nbsp;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用。 营销系统和订单系统是同层关系，就用消息中间件。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;3.设计模块的接口（给外部使用的）、数据库、业务模型：&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;我们在设计接&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;口和数据库的时候，一定要多花点心思和时间，切不可过于随意。相反，业务逻辑代码侧重&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。&amp;nbsp;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot; face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;接口的粒度应该是越小越好，但是对外部来说并不是，接口越小调用接口就越多，走网络耗时就越长，还涉及到分布式事务的数据一致性问题，&lt;/font&gt;所以，为了兼顾易用性和性能，我们可以借鉴&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;部使用。&amp;nbsp;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;我们为什么要使用MVC分层架构开发？单层开发不好吗？&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;1.分层能起到代码复用的作用。2.分层能起到隔离变化的作用。3.分层能起到隔离关注点的作用，单一职责。4.分层能提高代码的可测试性。&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;还有之前提到的，VO、BO、Entity的成员，基本上都差不多，需不需要重复定义类呢？&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;推荐每层都定义各自的数据对象这种设计思路，还是有细微的差别，数据库查询出来的所有，不可能都显示给页面。&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;虽然代码重复，但功能语义不重复，从职责上讲是不一样的。&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;所以，也并不能算违背 DRY 原则。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;虽然这样的设计稍微有些繁琐，每层都需要定义&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;说，结构清晰是第一位的！&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;那这样有重复的代码，怎么办？公共的字段抽取到一个父类里面。通过继承或者组合即可。&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; background-color: initial;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot; face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;vo、bo、entity都需要设计成充血吗？不需要，业务层的实体弄成充血就行了。因为业务层有很多复杂逻辑代码，很可能被修改了。&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot; face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;&lt;span style=&quot;font-size: 17.0079px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="240" y="5780" width="1070" height="1060" as="geometry" />
        </mxCell>
        <mxCell id="vVBWxAJ4765AQ51cDCxZ-2" value="抽象、分层、底层要足够通用" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="10" y="5850" width="180" height="100" as="geometry" />
        </mxCell>
        <mxCell id="vVBWxAJ4765AQ51cDCxZ-3" value="感觉DDD就是基于面向对象编程的，这样的代码容易扩展。" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry y="5990" width="180" height="100" as="geometry" />
        </mxCell>
        <mxCell id="vVBWxAJ4765AQ51cDCxZ-4" value="&lt;div&gt;&lt;div&gt;&lt;b&gt;非业务功能的开发设计（通用框架）：&lt;/b&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;除了功能性需求分析之外，还需要&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;考虑框架的非功能性需求。比如，框架的易用性、性能、扩展性、容错性、通用性等。&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;画产品线框图、聚焦简单应用场景、设计实现最小原型、画系统设计图等。这些方法的目的&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;都是为了让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1350" y="5760" width="1030" height="190" as="geometry" />
        </mxCell>
        <mxCell id="XVt_O5pLmTvRJdW2flsF-1" value="&lt;font color=&quot;#ff0000&quot;&gt;系统设计或者需求设计，我们把功能点列出来，然后找出需要扩展的哪些功能点、方法。然后把它们抽象成抽象方法，或者接口方法&lt;/font&gt;" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=18;" parent="1" vertex="1">
          <mxGeometry x="30" y="5670" width="1110" height="90" as="geometry" />
        </mxCell>
        <mxCell id="yvHY59e5LVk5bjqh0QID-1" value="&lt;div&gt;&lt;div&gt;重构的目的（why）、对象（what）、时机（when）、方&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;法（how）&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;font face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;&lt;span style=&quot;font-size: 17.0079px;&quot;&gt;我们写代码，开始的时候写出一个实现功能的版本即可，然后进行重构迭代，&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;font face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;&lt;span style=&quot;font-size: 17.0079px;&quot;&gt;当你单元测试不好写的时候，说明代码就需要进行重构了。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;保证重构不出错的手段：单元测试和代码的可测试性；&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;不同规模的重构：大规模高层次重构（比如系统、模块、代码结构、类与类之&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;间的交互等的重构）和小规模低层次重构（类、函数、变量等的重构）&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;重构的经验，1.工作中鼓励持续重构，但不赞成为了重构而重构.2.重构一定要在有比较完善的测试用例覆盖和回归用例库的情况下进行(可测试性)，否则会相当危险。3. 重构最好有AB工具灰度比对，逐步切流。4. 重构最好有资深的成员共同CR，结合大家的意见，可能本次的重构也会引入一些怪味道。&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;重构的教训，出现问题的场景往往在于一个细小的点，能注意到的往往没有问题。 重构一旦出问题会面临比较大的精神压力和信心挑战，会部分挫败重构者的积极性，这时候需要TL的鼓励和支持，避免让员工感受到做多错多。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1350" y="5990" width="1060" height="430" as="geometry" />
        </mxCell>
        <mxCell id="yvHY59e5LVk5bjqh0QID-2" value="&lt;div&gt;&lt;div&gt;单元测试：&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;写单元测试就是针对代码设计覆盖各种输入、异常、边&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;界条件的测试用例，并将这些测试用例翻译成代码的过程。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;font face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;&lt;span style=&quot;font-size: 17.0079px;&quot;&gt;为了能够好写单元测试：&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;&lt;span style=&quot;font-size: 17.0079px;&quot;&gt;1.代码上尽量用抽象 用接口代替实现编程。方便进行mock测试（自己写一个类（返回写死）来替换原来代码里面的。）。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;&lt;span style=&quot;font-size: 17.0079px;&quot;&gt;2.单例类（工具、或者第三方框架使用的类），无法通过mock来实现替换类。如果我们自己能改这块代码，可以把单例改成实现一个接口，然后使用的地方，用依赖注入，注入一个接口，这样就可以替换了。如果不能修改，就自己再新增一个类，对单例类进行单独的包装，单元测试的时候可以new一个新的对象实现。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;&lt;span style=&quot;font-size: 17.0079px;&quot;&gt;3.时间字段，我们面向对象变成，时间字段可能只会有一个get方法，里面是DataTime.Now.toString()，为了不破坏封装性，可能不会提供set方法。那单元测试需要测时间相关的怎么办？比如封装一个方法isExpired()用来判断时间是否超时，测试的时候，new一个类，然后重写这个方法即可。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font face=&quot;微软雅黑&quot; color=&quot;#353535&quot;&gt;&lt;span style=&quot;font-size: 17.0079px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;代码中包含跟“时间”有关的“未决行为”逻辑。我们&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;一般的处理方式是将这种未决行为逻辑重新封装。&lt;/span&gt;所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;的代码。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1350" y="6530" width="1085" height="410" as="geometry" />
        </mxCell>
        <mxCell id="GqpLYzD-g6mrbK_Qvi9X-1" value="可进行单元测试的代码，大概需要：1.基于接口而非实现编程。2.实现依赖反转原则：依赖注入。" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=18;" vertex="1" parent="1">
          <mxGeometry x="1480" y="6460" width="950" height="50" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
