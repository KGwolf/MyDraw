<mxfile host="app.diagrams.net" modified="2024-01-19T01:57:19.742Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" etag="cYennTqKUOQnNiANJfN3" version="22.1.21" type="github">
  <diagram name="第 1 页" id="1XJYP80JxbJxhC29MnGr">
    <mxGraphModel dx="1434" dy="1927" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="axaWvUbI3fm5PjR0QgIP-2" value="分布式缓存：&lt;br&gt;选择Redis作为分布式存储中间件。&lt;br&gt;我们存储的是什么？&lt;br&gt;我们用redis来存储消息ID，当我们需要通知消息的时候，就生成一条记录（id，content）保存到数据库的一张表,content为具体的任务的json串。&lt;br&gt;那为什么我们不存储具体的任务信息？&lt;br&gt;因为考虑到信息安全问题。可能是想防止小pass。以及信息安全吧，最主要的可能是pass的规则问题。那是公司的命根子，不能让实施或者开发轻易拿到，他们现在的方式是存到一个加密的文件，具体怎么加密的，确实不清楚。&lt;br&gt;&lt;br&gt;问题：我们为什么不用消息队列呢？&lt;br&gt;&lt;br&gt;问题：如果我们每个缓存状态更改，都需要通知Redis来广播到每个节点，那么会不会导致服务器压力变大？我们的状态变更还是很频繁的&lt;br&gt;&lt;br&gt;经过讨论，第一版本，是在网关端做负载均衡的配置，同一个ip的所有请求负载到同一个节点上面。这样就不用频繁的进行内存数据的同步了。然后在保存数据库的时候（包括业务本身的数据入库，和缓存消息的入库），再给redis发缓存消息ID&quot;{\&quot;messageid\&quot;,\&#39;xxx\&#39;}&quot;，由redis进行广播，所有的PR分布式节点都进行订阅去同步消息（根据消息ID去数据库里面查询具体的任务信息串）。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="70" y="100" width="840" height="250" as="geometry" />
        </mxCell>
        <mxCell id="axaWvUbI3fm5PjR0QgIP-3" value="分布式数据库：&lt;br&gt;读写分离（主从，没有做主备），历史库。&lt;br&gt;&lt;br&gt;只要有写的方法，都走的是主库。只有查询的都走的是从库。&lt;br&gt;然后历史库，需要前端来配合，需要前端根据页面选择查询的时间来判断走的是不是历史库。然后传值给后端，进行注解的判断？&lt;br&gt;&lt;br&gt;数据库使用的pgsql，可以自己做主从复制，中间件的主从复制一般有2种，1.快照模式。2.增量语句执行。&lt;br&gt;我们公司的pgsql应该用的是WAL（Write-Ahead Logging）来在主服务器和从服务器之间传输事务日志，从而保持从服务器的数据与主服务器的数据同步。&lt;br&gt;&lt;br&gt;在程序里，使用dynamicdatasource来做的主从读写分离。配置多个数据源。然后在每个方法上面加上注解@DS(&quot;slave&quot;)。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="80" y="610" width="800" height="180" as="geometry" />
        </mxCell>
        <mxCell id="lYMavn7DF4E9moOjVgNg-1" value="如果网关层不使用IP负载的模式，那么请求就可能会被打散到所有的pr服务节点上面，那么就必须要求缓存一致性，且强一一致缓存。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1010" y="100" width="320" height="110" as="geometry" />
        </mxCell>
        <mxCell id="lYMavn7DF4E9moOjVgNg-2" value="需要搞清楚java版本的提请审核之后，怎么到药师端提醒有任务的？再来分析下面的需求。&lt;br&gt;&lt;br&gt;我们有一种模式，是分药房模式，可能不同的药师监测不同的药房。那么就会有子任务出现。由不同的药师来进行审核。那如果用同一IP的请求到同一个服务器。那么" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="980" y="250" width="320" height="110" as="geometry" />
        </mxCell>
        <mxCell id="lYMavn7DF4E9moOjVgNg-3" value="公司整个PASS项目是一个微服务项目。&lt;br&gt;&lt;br&gt;PR作为其中的一个微服务。&lt;br&gt;&lt;br&gt;我们做的是集群。分担医生站来的请求压力。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="290" y="-30" width="320" height="110" as="geometry" />
        </mxCell>
        <mxCell id="lYMavn7DF4E9moOjVgNg-4" value="由于reids的广播消息不算很靠谱的，那我们要怎么保证各个节点的内存数据同步呢？&lt;br&gt;&lt;br&gt;跑定时任务？每个缓存对象（caseid对应的一个任务）查看其中的时间戳，是不是跟数据库的能对应上。如果不能则更新最新的数据到未成功同步的节点？那么是否会导致效率的问题呢？&lt;br&gt;&lt;br&gt;方案2：每个PR后端节点链接redis的时候，都在redis里面存上各自的ip？有什么用呢？&lt;br&gt;&lt;br&gt;因为我们缓存只存消息ID，所以不管是同步消息，还是定时任务去查缓存不一致，都需要查询数据库，这样会不会导致数据库崩掉？？" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="150" y="380" width="620" height="180" as="geometry" />
        </mxCell>
        <mxCell id="azIFYM6eBztKxtA_MHt6-1" value="性能优化：&lt;br&gt;用jmiter做压测，我们.net版本的 门诊80，住院120，加起来就是200。应该说的是QPS？&lt;br&gt;java版本的性能要差点。首次排查可能是因为Disruptor的线程引起的，生产者线程1个，然后消费者线程N个。还未排查出是不是这个问题。&lt;br&gt;&lt;br&gt;&lt;br&gt;bs优化：&lt;br&gt;首先后端逻辑很多+=，改成StringBuilder。&lt;br&gt;然后页面优化（重点）：因为业务需求原因，我们需要在页面存储2个大的JSON串。还有就是JS文件，刚开始也是跟html写到一起的，大概有几千行JS代码，且里面有需要thymleaf解析的代码。&lt;br&gt;解决步骤：大的JSOn串缓存在后端，根据taskid来进行缓存，当页面加载完成之后，再ajax同步从后端缓存取，取完就删除，这样也不会占用内存。&lt;br&gt;同时，把JS分离开到单独的文件。需要后端在JS解析的代码，修改成Js变量。这样不用解析。&lt;br&gt;改完之后，完全能撑住200并发了。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="90" y="910" width="810" height="230" as="geometry" />
        </mxCell>
        <mxCell id="OiV16W11Bcy6xy-m6XNg-1" value="要搞清楚.net版本和java版本统计分析和查询的逻辑，从开始的查询和统计分析进行硬查询，到进行预处理查询，再到进行优化。&lt;br&gt;&lt;br&gt;.net版本的统计分析痛点：预处理到表里面的是具体的count，比如预处理表的字段：提交数-10，干预数-20，双签数-30等等，而点击链接是进行代码逻辑硬查询（虽然也是查询预处理表，但是指标逻辑是可以跟随需求而变动的），但是预处理到表里面的历史数据，count是不能改变的，就导致了count跟实际链接查询出来的数据不一致。解决办法就要进行刷历史数据，这个过程比较耗时。&lt;br&gt;&lt;br&gt;java版本解决了这个痛点，首先预处理到表里面的不在是count，而是一个标记，比如：auditmodeid&amp;nbsp; 提交数-1 干预数-0，当查询详情的时候，根据只需要判断&amp;gt;0即可。这样能跟整个统计出来的数字对应上。但是这种情况虽然对应上了，如果指标算法变了的话（具体怎么变化？），那么历史数据的count跟变了之后想要的count是对不上的。但是这个就容错高些了。看医院需不需要统一，如果需要就刷历史数据。主动权给到医院。有的医院不需要刷，有的可能需要。" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="980" y="440" width="460" height="250" as="geometry" />
        </mxCell>
        <mxCell id="0i6LU9kepRgSpGDFbb0o-1" value="公共的逻辑可以放哪里，会变化的逻辑放哪里，怎么进行封装，可以看看AQS源码，Spring源码，Tomcat源码" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="750" y="-110" width="300" height="60" as="geometry" />
        </mxCell>
        <mxCell id="M4xeJUEj8VqUzHAWt1Ij-1" value="Redis，PR用的是hash存储。对象通过序列化，反序列化的方式进行存储。&lt;br&gt;类里面的方法不能以is开头，否则反序列化会报错，当然这根序列化器有关系，可以自定义吧？" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="690" y="-10" width="300" height="80" as="geometry" />
        </mxCell>
        <mxCell id="pnb352GZgsO-i2-xDFfo-1" value="可以吧PR的任务生成，加上一个抢单的功能！！！&lt;br&gt;&lt;br&gt;分布式环境下的！！！！&lt;br&gt;&lt;br&gt;redis可以用reddison来做分布式锁的框架！" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="340" y="-180" width="310" height="90" as="geometry" />
        </mxCell>
        <mxCell id="GLIDyd0n-ON3j2NHpdD_-1" value="Disruptor，在高并发下面报错：&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2023-12-14 09:26:15[disruptor-3]ERROR c.m.m d.h. DatalWrapperEventHandler - workHandler-3解析队列数据对象 保存病人药品医嘱信息-&amp;gt;null&lt;br&gt;java.lang.NullPointerException: null&lt;br&gt;&amp;nbsp;at com.medicom.modules.disruptor.handler.DatawrapperEventHandler.onEvent(DatawrapperEventHandler.java:40)&lt;br&gt;&amp;nbsp;at com.medicom.modules.disruptor.handler.DataWrapperEventHandler.onEvent (DatawrapperEventHandler.java:18)&lt;br&gt;at com.lmax.disruptor.workProcessor.run (WorkProcessor.java:143)&lt;br&gt;&lt;br&gt;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)&lt;br&gt;at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)&lt;br&gt;at java.lang.Thread.run (Thread.java : 748)&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;EnCache，在高并发下面报错：&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;存放encache+类有继承关系，类需要实现Serialzable接口，且在子类上需要加上@EqualsAndHashCode(callSuper=true)，防止从磁盘里面读取进行反序列化时父类为null。&amp;nbsp;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1140" y="-350" width="670" height="390" as="geometry" />
        </mxCell>
        <mxCell id="GLIDyd0n-ON3j2NHpdD_-2" value="表分区，分区到不同磁盘？好处是什么？" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="720" y="-270" width="300" height="60" as="geometry" />
        </mxCell>
        <mxCell id="52weYLeMf9iYNcdraF4N-1" value="&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;，优化性能，发现很多类的转换，开始用的&lt;/font&gt;BeanUtil.toBean，这种是通过反射的方式来得到转换后的对象，&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;高并发下测试比较耗费性能。每个响应多耗时400ms,并发数少20个。&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;ClinicMainTaskInfo entity = BeanUtil.toBean(bean, PrClassUtils.CLINIC_MAIN_TASK_INFO);&lt;/font&gt;&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/pre&gt;&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;pre style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;ClinicMainTaskInfo entity = TaskInfoMainBeanConvert.INSTANCE.convertToClinicMainTaskInfo(bean);&lt;/font&gt;&lt;/pre&gt;&lt;/pre&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1890" y="-310" width="900" height="350" as="geometry" />
        </mxCell>
        <mxCell id="52weYLeMf9iYNcdraF4N-2" value="&lt;pre style=&quot;font-size: 18px;&quot;&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;JetBrains Mono&#39;,monospace;font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;import &lt;/span&gt;org.mapstruct.&lt;span style=&quot;color:#bbb529;&quot;&gt;Mapper&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;import &lt;/span&gt;org.mapstruct.factory.Mappers&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@ClassName: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;TaskInfoMainBeanConvert&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Description: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;转换主任务对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Author: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Date: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Version: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;V1.0&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Mapper&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public interface &lt;/span&gt;TaskInfoMainBeanConvert {&lt;br&gt;    TaskInfoMainBeanConvert &lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;INSTANCE &lt;/span&gt;= Mappers.&lt;span style=&quot;font-style:italic;&quot;&gt;getMapper&lt;/span&gt;(TaskInfoMainBeanConvert.&lt;span style=&quot;color:#cc7832;&quot;&gt;class&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@param &lt;/span&gt;&lt;span style=&quot;color:#8a653b;font-style:italic;&quot;&gt;bean &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;待转化对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;     &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@return &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Description &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;     &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Author &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Date &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;TaskInfoMainBean &lt;span style=&quot;color:#ffc66d;&quot;&gt;convertToTaskInfoMainBean&lt;/span&gt;(TaskInfoMainBean bean)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@param &lt;/span&gt;&lt;span style=&quot;color:#8a653b;font-style:italic;&quot;&gt;bean &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;待转化对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;     &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@return &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;ClinicMainTaskInfo&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Description &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;     &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Author&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;ClinicMainTaskInfo &lt;span style=&quot;color:#ffc66d;&quot;&gt;convertToClinicMainTaskInfo&lt;/span&gt;(TaskInfoMainBean bean)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;InHospMainTaskInfo &lt;span style=&quot;color:#ffc66d;&quot;&gt;convertToInHospMainTaskInfo&lt;/span&gt;(TaskInfoMainBean bean)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;InterMainTaskInfo &lt;span style=&quot;color:#ffc66d;&quot;&gt;convertToInterMainTaskInfo&lt;/span&gt;(TaskInfoMainBean bean)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;br&gt;&lt;/pre&gt;&lt;/pre&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="2895" y="-330" width="745" height="880" as="geometry" />
        </mxCell>
        <mxCell id="CAA8TabalaVCixUhrOd4-1" value="可以回退到12月份代码进行性能测试。" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="2160" y="-410" width="290" height="80" as="geometry" />
        </mxCell>
        <mxCell id="4FLja5BOqqyU_yTpesLY-1" value="IM，有一个问题，超过6个页面嵌套之后，会导致浏览器请求卡死。&lt;br&gt;&lt;p&gt;浏览器对同一个域名下并行连接数有限制，这一限制通常被称为&quot;并发连接数&quot;。这是因为浏览器为了避免过多的并发请求对网络性能造成负面影响，对同一个域名下的并发连接数进行了限制。&lt;/p&gt;&lt;p&gt;通常，对于 HTTP/1.1 协议，浏览器对同一域名下的并发连接数限制为 6-8 个&lt;/p&gt;&lt;p&gt;具体原因：因为要兼容IE6，所以不能使用WebSocket的方式，使用的是comet方式通信&lt;/p&gt;&lt;p&gt;Comet 是一种通过持续连接（long-polling 或 streaming）实现服务器推送数据到客户端的通信方式，以实现实时更新的目的。这种通信方式主要应用于需要实时性的网络应用，比如聊天应用、实时消息推送等。&lt;br&gt;&lt;/p&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Long Polling（长轮询）：&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;在长轮询中，客户端向服务器发送一个请求，并保持该请求处于挂起状态，直到服务器有新的数据可用或超时为止。&lt;/li&gt;&lt;li&gt;服务器在有新数据可用时，立即将数据发送给客户端，并关闭连接。&lt;/li&gt;&lt;li&gt;客户端在收到数据后，立即发起下一个请求，保持连接处于持续状态。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Streaming（流式传输）：&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;在流式传输中，客户端与服务器建立一条持久连接，服务器可以在任何时候向客户端发送数据。&lt;/li&gt;&lt;li&gt;服务器将数据以流的形式发送给客户端，客户端可以实时接收并处理这些数据。&lt;/li&gt;&lt;li&gt;这种方式相比长轮询来说，更加实时，因为在有新数据时，服务器可以立即将其推送给客户端。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;Comet 方式通信的优点包括实时性强、无需频繁的轮询请求、降低了延迟等。然而，也存在一些缺点，如较高的服务器资源占用、可能会受到浏览器连接数限制等。&lt;/p&gt;&lt;p&gt;在现代的 Web 开发中，WebSocket 技术逐渐成为了一种更为高效的实时通信方式，因为它提供了双向通信的能力，而不需要像 Comet 那样通过多次 HTTP 请求。WebSocket 允许服务器主动向客户端推送消息，同时保持低延迟和更高的效率。&lt;/p&gt;&lt;/li&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="30" y="-820" width="600" height="570" as="geometry" />
        </mxCell>
        <mxCell id="K7jlHJTKLegIbDve6_yx-1" value="序列化问题：&lt;br&gt;序列化主要用于：1.类的网络传输（需要弄成二进制）。2.类的持久化。&lt;br&gt;&lt;br&gt;1.使用java中的Serializable接口：效率慢，占用空间大，无法跨语言。&lt;br&gt;&lt;br&gt;2.使用其它框架，怎么选型？&lt;br&gt;&amp;nbsp;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;是否需要跨语言支持。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;空间：编码后的空间占用&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;时间：编码所需的时间&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;是否追求可读性。（Json具有可读性，二进制没有）&lt;br&gt;&lt;br&gt;&lt;br&gt;如果是应用层，一般选择序列化成Json进行持久化或者网络传输，Json是跨语言的，并且可读性高。&lt;br&gt;&lt;br&gt;如果是用作RPC、分布式节点间通信，可选择Json，也可选择高效率的二进制序列化。" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="850" y="-890" width="660" height="410" as="geometry" />
        </mxCell>
        <mxCell id="FtiWQNE3cC4o1lRVwpFo-1" value="面向对象3大特性：&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;封装：封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类&lt;span style=&quot;background-color: initial;&quot;&gt;提供的方式来访问内部信息或者数据。&lt;/span&gt;封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。易用就是不关系具体方法里面的实现。&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; 抽象：&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;继承：主要解决代码复用问题。&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;多态：之类可以替换父类，运行时执行子类的代码。需要变成语言的语法支持。提高代码的可扩展性和复用性。&lt;br&gt;&lt;br&gt;&lt;br&gt;面向过程和面向对象的区别？&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。&lt;br&gt;&lt;br&gt;面向对象的优势：&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;1.能够应对大型复杂的项目开发。进行业务建模，将需求翻译成类，思考类之间的交互关系，然后再处理业务流程，组装成程序。面向过程也可以写出面向对象的代码！&lt;br&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;2.面向对象风格的代码更易复用、易扩展、易维护。&lt;br&gt;&lt;br&gt;&lt;br&gt;自己平时写的代码，自认为是面向对象的，其实是面向过程的。。。。并不是把所有的东西都糅到1个类里面就算是面向对象了。&lt;br&gt;&lt;br&gt;哪些代码设计看似是面向对象，其实是面向过程？&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;1.滥用getter、setter。或者@Data：违反了封装的特性，如右边所示。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;定义类属性时，尽量不定义setter方法（@Getter），同时getter方法也要注意集合内部元素被修改。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;2.滥用全局变量和全局方法：各种静态工具类，静态常量类，&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;喜欢所有的东西都放在一个静态常量类里面：可维护性低、代码编译时间长、复用性低。应该根据业务分成多个静态常量类，或者把常量定义在相关的类里面。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;3.定义数据和方法分离的类：基本每天都在写，mvc模式，定义的vo、bo、entity基本都是，只定义数据，不定义方法，都是在业务层操作这些数据。这也是贫血模型。典型的面向过程开发风格。" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="110" y="1420" width="1060" height="860" as="geometry" />
        </mxCell>
        <mxCell id="FN0yQ43i4ETcDHctbkBb-1" value="&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;JetBrains Mono&#39;,monospace;font-size:12.0pt;&quot;&gt;&lt;pre style=&quot;font-family: &amp;quot;JetBrains Mono&amp;quot;, monospace; font-size: 12pt;&quot;&gt;import lombok.&lt;span style=&quot;color:#bbb529;&quot;&gt;Data&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;import &lt;/span&gt;java.util.Collections&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;import &lt;/span&gt;java.util.List&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@ClassName: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;OOPClass&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Description: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;这就是我们平时用的类定义，其实就是面向过程的风格，跟定义成&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;其实没区别了，这里面存在一些问题：&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* 1.totalAccount&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;的值可能跟&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;accountName&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;的实际数量不一致。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* 2.totalMoney&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;应该是私有的数据，根据面向对象的封装特性，应该额外提供方法来给外界调用（&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;increaseTotalMoney(),decreaseTotalMoney()&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;），&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;在方法里面还可以做一些额外的逻辑判断，比如权限等等。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* 3.accountName&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;这个集合值，首先不应该提供&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;setter&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;方法，其次，提供&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;getter&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;方法之后，外界拿到了之后可能对其进行修改，或者&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;clear()&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;，很危险。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;那这时可以改成&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;Collections.unmodifiableList()&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt;，改了之后，还有个问题，外界拿到集合之后，如果元素是对象，修改对象的某个属性怎么办？&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;font-family:&#39;宋体&#39;,monospace;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Author: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;xiahaitao&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Date: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;2024/1/16 11:01&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@Version: &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;V1.0&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Data&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public class &lt;/span&gt;OOPClass {&lt;br&gt;    &lt;span style=&quot;color:#cc7832;&quot;&gt;private &lt;/span&gt;String &lt;span style=&quot;color:#9876aa;&quot;&gt;name&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    private int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;age&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    private &lt;/span&gt;List&amp;lt;String&amp;gt; &lt;span style=&quot;color:#9876aa;&quot;&gt;accountName&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//    private List&amp;lt;String&amp;gt; getAccountName(){&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//        return Collections.unmodifiableList(accountName);&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//    }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;totalAccount&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    private int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;totalMoney&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;br&gt;&lt;/pre&gt;&lt;/pre&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1260" y="1600" width="1100" height="580" as="geometry" />
        </mxCell>
        <mxCell id="FN0yQ43i4ETcDHctbkBb-3" value="接口和抽象类：&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;抽象类：1. 不能被实例化，只能被继承。可以有属性和方法，方法可以不包含实现（抽象方法）。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.子类继承抽象类，必须实现所有的抽象方法。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&amp;nbsp; &amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;is a 的关系。多是为了解决代码复用的问题。 典型的用法，模板设计模式。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;接口：不能包含属性，只能声明方法，不能有实现。类实现接口，必须实现接口中所有的方法。 has a 的关系，表示具有某一组行为特性，解决的是解耦问题，隔离接口和具体的实现，提高扩展性。&lt;br&gt;&lt;br&gt;&lt;br&gt;基于接口而非实现编程（基于抽象而非实现编程）：一定&lt;span style=&quot;background-color: initial;&quot;&gt;要有抽象意识、封装意识、接口意识。越抽象越顶层、越脱离具体某一实现的设计，越能&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;提高代码的灵活性、扩展性、可维护性。&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;1.函数的命名不能暴露任何细节。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.封装具体的细节。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;3.为实现类定义抽象的接口。&lt;br&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;IUpload&amp;nbsp; upload = new AliYunUpLoad();&amp;nbsp; 这里是new出来具体的实现类，那么如果需要换一种上传方式，就需要改代码了，有没有好的方式？" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="120" y="2290" width="1070" height="440" as="geometry" />
        </mxCell>
        <mxCell id="J9Vd1cQ4T2tUTU1RXiHH-1" value="&lt;div&gt;组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;继承层次过深、过复杂，也会影响到代码的可维护性，继承爆炸。&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;可以利用组合（composition）、接口、委托（delegation）三个技术手&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;段，一块儿来解决继承存在的问题。&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;组合：将对象组装在一起以创建更复杂对象的方式（将类实例化到另外一个类里面）。&amp;nbsp; &amp;nbsp; 委托：将某个对象的责任委托给另一个对象的机制。&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;Spring的依赖注入跟这个有没有关联？&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;Entity、BO、VO 三者之间的代码有很大重复，但又不完全相同。我们该如&lt;span style=&quot;background-color: initial;&quot;&gt;何处理 Entity、BO、VO 代码重复的问题呢？&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1250" y="2320" width="1030" height="270" as="geometry" />
        </mxCell>
        <mxCell id="J9Vd1cQ4T2tUTU1RXiHH-2" value="把PR里面的TaskInfo改造成面向对象，并且从单纯的继承改造成组合。" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=18;" parent="1" vertex="1">
          <mxGeometry x="1290" y="2240" width="740" height="60" as="geometry" />
        </mxCell>
        <mxCell id="J9Vd1cQ4T2tUTU1RXiHH-3" value="&lt;div&gt;贫血模型、充血模型（DDD）：&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;我们几乎所有的项目都是贫血模型，基于面向过程开发，每个类里面基本只有字段，将数据与业务逻辑操作进行分离，背离了面向对象的封装特性。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;DDD充血模型，则相反，将数据与业务逻辑封装到一个类里面，符合了面向对象编程风格。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;DDD实现的代码，也是基于三层架构，Controller层、Repository层都不变，变化的只是Service层。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;为什么我们都喜欢用贫血模型进行面向过程开发？&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;业务简单。设计简单，充血模型设计困难。学习成本。&amp;nbsp; &amp;nbsp;DDD充血模型适合业务复杂、稳定的项目。&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1250" y="2620" width="1030" height="270" as="geometry" />
        </mxCell>
        <mxCell id="tLVYLYFxv8BBkOP2GH6Q-1" value="&lt;div&gt;利用DDD开发一个钱包功能：自己看文档！！！&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在基于充血模型的 DDD 开发模式中，将业务逻辑移动到Domain 中，Service 类变得很薄，但在我们的代码设计与实现中，并没有完全将Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;1.Service 类负责与 Repository 交流。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.Service 类负责跨领域模型的业务聚合功能。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;3.Service 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消&lt;span style=&quot;background-color: initial;&quot;&gt;息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;没必要！业务逻辑比较简单，或者不需要逻辑比如Vo对象，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我对DDD的看法就是，它可以把原来最重的service逻辑拆分并且转移一部分逻辑，可以使得代码可读性略微提高，另一个比较重要的点是使得模型充血以后，基于模型的业务抽象在不断的迭代之后会越来越明确，业务的细节会越来越精准，通过阅读模型的充血行为代码，能够极快的了解系统的业务，对于开发来说能说明显的提升开发效率。&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1250" y="2910" width="1080" height="510" as="geometry" />
        </mxCell>
        <mxCell id="tLVYLYFxv8BBkOP2GH6Q-2" value="&lt;div&gt;面向对象分析（OOA，需求分析）、面向对象设计（OOD，设计各种类）、面向对象编程（OOP），是面向对象开发的三个主要环节。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;“为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。”&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;分析：1.appid+秘钥鉴权(给调用方)，这种秘钥容易被截获。2.appid+加密后的秘钥，也容易被截获，重放攻击。3.传参appid+秘钥+时间戳+由前面几个参数生成的token，后端解析token，验证时间戳是否在有效范围内。虽然也会被重放攻击，但是有时间范围。增大攻击的难度。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如何做需求分析，如何做职责划分？需要定义哪些类？每个类应该具有哪些属性、方法？类与类之间该如何交互？如何组装类成一个可执行的程序？&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;划分职责而进一步识别出有哪些类、定义类及其属性和方法、定义类与类之间的交互关系、将类组装起来并提供执行入口。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;根据需求描述，把其中涉及的功能点，一个一个罗列出来，要分的很细很细！！！，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。（建议用这个识别出有哪些类）&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;1.将url、appid、秘钥、时间戳拼成字符串。&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;2.SHA加密算法加密字符串成一个token。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;3.拼接url。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;4.后端解析url。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;5.后端拿到appid对应的秘钥等信息。（这里可以从redis、mysql等地方拿，设计成接口合适）&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;6.根据时间戳判断token是否过期。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;7.验证token是否相等。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4两个操作；CredentialStorage 负责 5 这个操作。（具体的定义看文档）&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;针对这种复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;对于方法的识别，很多面向对象相关的书籍，一般都是这么讲的，识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。&lt;br&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;将类组装起来，提供执行入口：Main函数或者提供api给外部。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;所以这里还是抽象出一个接口，给外部提供方法使用：ApiAuthencator接口。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;br&gt;&lt;br&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="60" y="2820" width="1170" height="900" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-1" value="类之间有哪些关系：&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;泛化（继承）、实现（接口实现）、关联（作为成员变量用到了另外的类）、聚合、组合、依赖（方法参数或者返回值用到了另外的类）。 &lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;其中聚合、组合、关联，统一可以看做是组合，作为成员变量用到了另外的类。&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1270" y="3450" width="1030" height="140" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-2" value="设计原则：&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;SOLID、KISS、YAGNI、DRY、LOD&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;SOLID：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单一职责原则（Single Responsibility Principle）：&lt;/strong&gt; 一个类应该只有一个引起变化的原因，即一个类应该只有一个职责。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;开放/封闭原则（Open/Closed Principle）：&lt;/strong&gt; 软件实体（类、模块、函数等）应该对扩展是开放的，但对修改是封闭的。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;里氏替换原则（Liskov Substitution Principle）：&lt;/strong&gt; 子类型必须能够替换掉它们的基类型。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;接口隔离原则（Interface Segregation Principle）：&lt;/strong&gt; 一个类不应该被强迫实现它不需要使用的接口。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;依赖反转原则（Dependency Inversion Principle）：&lt;/strong&gt; 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于具体实现，而具体实现应该依赖于抽象。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;KISS：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;保持简单原则（Keep It Simple, Stupid）：&lt;/strong&gt; 程序应该保持简单，易于理解和维护。过度的复杂性往往会导致不必要的问题。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;YAGNI：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;你不需要它原则（You Aren&#39;t Gonna Need It）：&lt;/strong&gt; 在实际需要之前，不要添加不必要的功能。避免过度设计和过早优化。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;DRY：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不要重复自己原则（Don&#39;t Repeat Yourself）：&lt;/strong&gt; 程序中的每一块知识都应该有一个明确、清晰、不可亵渎的单一表示。避免代码重复，使用抽象和模块化。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;LOD：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;迪米特法则（Law of Demeter）：&lt;/strong&gt; 一个对象应该对其他对象有最少的了解。一个类应该对自己需要调用的方法知之甚少，尽量降低类之间的耦合度。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="60" y="3790" width="1460" height="600" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-3" value="支持达梦数据库、OceanBase数据库。&lt;br&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="700" y="-390" width="300" height="60" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-4" value="&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;单一职责原则（Single Responsibility Principle）&lt;br&gt;&lt;/strong&gt;&lt;div&gt;一个类的代码行数最好不能超过 200 行，函数&lt;span style=&quot;background-color: initial;&quot;&gt;个数及属性个数都最好不要超过 10 个。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。&lt;br&gt;&lt;br&gt;类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；&lt;br&gt;&lt;br&gt;&lt;div&gt;类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，&lt;span style=&quot;background-color: initial;&quot;&gt;我们就需要考虑对类进行拆分；&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供&lt;span style=&quot;background-color: initial;&quot;&gt;更多的类使用，从而提高代码的复用性；&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的&lt;span style=&quot;background-color: initial;&quot;&gt;Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半&lt;span style=&quot;background-color: initial;&quot;&gt;的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1580" y="3790" width="1040" height="390" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-5" value="&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;开放/封闭原则（Open/Closed Principle）&lt;br&gt;&lt;/strong&gt;因为需求有增加，需要对原来的类方法做修改（参数的添加、里面逻辑的增加或修改）。这意味着调用&lt;span style=&quot;background-color: initial;&quot;&gt;这个接口的代码都要做相应的修改。&lt;/span&gt;相应的单元测试都需&lt;span style=&quot;background-color: initial;&quot;&gt;要修改。&lt;/span&gt;这种是基于“修改”的方式来实现新功能。那怎么用扩展来实现新功能呢？&lt;br&gt;&lt;br&gt;&lt;br&gt;1.将方法的参数封装成1个类。&lt;br&gt;2.引入handler的概念，把if判断逻辑分散在各个handler中。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，&lt;span style=&quot;background-color: initial;&quot;&gt;这个是做不到的。只要它没有破坏原有的代码的正常运&lt;/span&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。&lt;/span&gt;我们要做的是尽量让修改操作更集中、更少、更上&lt;span style=&quot;background-color: initial;&quot;&gt;层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;为了尽量写出扩展性好&lt;span style=&quot;background-color: initial;&quot;&gt;的代码，我们要时刻具备扩展意识、抽象意识、封装意识。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;23 种经典设计模式，大部分都是&lt;span style=&quot;background-color: initial;&quot;&gt;为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;最常用来提高代码扩展性的方法有：多态、依赖注入、&lt;span style=&quot;background-color: initial;&quot;&gt;基于接口而非实现编程，以及大部分的设计模式。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;div&gt;对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是&lt;span style=&quot;background-color: initial;&quot;&gt;为了让系统更有弹性！&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1570" y="4230" width="1040" height="430" as="geometry" />
        </mxCell>
        <mxCell id="xBOe5HQ8ipK4dN4GoOSR-6" value="&lt;div&gt;&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;里氏替换原则（Liskov Substitution Principle）:&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;&lt;br&gt;&lt;/strong&gt;&lt;/div&gt;子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。&amp;nbsp;&lt;br&gt;&lt;br&gt;&lt;div&gt;&lt;b&gt;咋一看，跟多态的概念有点像，实际上是2种不一样的东西！！！！！！它们的关注角度是不一样的，多态是语言的一种和编译器支持的一种语法。里氏替换关注的是子类如何进行设计，保证逻辑的正确性（跟父类的行为一样）！&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;子类在设计的时候，要遵守父类的行为约定（或者&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;也可以替换成接口和实现类之间的关系。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;理解里式替换原则，最&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;包括注释中所罗列的任何特殊说明。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;哪些是破坏了里氏替换原则？&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;1.父类方法返回集合，排序按照A字段，子类相同方法返回集合，排序却是按照B字段。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;2.返回值，一个返回null，一个返回new 对象。等等。。。。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;里氏替换的意义：&lt;/div&gt;&lt;div&gt;一、改进已有实现。例如程序最开始实现时采用了低效的排序算法，改进时使用LSP实现更高效的排序算法。&lt;br&gt;&lt;/div&gt;&lt;div&gt; 二、指导程序开发。告诉我们如何组织类和子类（subtype），子类的方法（非私有方法）要符合约定。&lt;br&gt;&lt;/div&gt;&lt;div&gt; 三、改进抽象设计。如果一个子类中的实现违反了LSP，那么是不是考虑抽象或者设计出了问题。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt; 多态是一种能力，而里氏替换原则一种约定，想要实现这种约定，需要依靠多态这种能力。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;里氏替换最终一句话还是对扩展开放，对修改关闭，不能改变父类的入参，返回，但是子&lt;span style=&quot;color: rgb(76, 76, 76); font-family: 微软雅黑; font-size: 12.0056pt; background-color: initial;&quot;&gt;类可以自己扩展方法中的逻辑。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="2670" y="3790" width="1070" height="660" as="geometry" />
        </mxCell>
        <mxCell id="Vjz6WrMUGAyvdLdzKQWN-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;怎么有种感觉，一切的原则都是给开放封闭原则铺路呢&lt;/font&gt;" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="1650" y="3650" width="500" height="100" as="geometry" />
        </mxCell>
        <mxCell id="Vjz6WrMUGAyvdLdzKQWN-2" value="&lt;div&gt;&lt;strong style=&quot;border-color: var(--border-color);&quot;&gt;接口隔离原则（Interface Segregation Principle）&lt;/strong&gt;&lt;br&gt;&lt;/div&gt;&amp;nbsp;一个类不应该被强迫实现它不需要使用的接口。&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;把&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;“&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;”&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;理解为一组&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt; API &lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口集合：&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;在设计微服务或者类库接口的时候，如果部&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7551pt; background-color: initial;&quot;&gt;分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;mso-spacerun:&#39;yes&#39;;font-size:12.7551pt;font-family:微软雅黑;color:rgb(53,53,53);&quot;&gt;用，而不是强迫其他调用者也依赖这部分不会被用到的接口。&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;mso-spacerun:&#39;yes&#39;;font-size:12.7551pt;font-family:微软雅黑;color:rgb(53,53,53);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;把&lt;span style=&quot;font-size: 15.006pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;“&lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口&lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;”&lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;理解为单个&lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt; API &lt;/span&gt;&lt;span style=&quot;font-size: 15.006pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口或函数：&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;函数的设计要功能单一，不要将多个不同的&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;功能逻辑在一个函数中实现。（这个看起来跟单一职责原则有点像呢）&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的&lt;/span&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;部分功能，那接口的设计就不够职责单一。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(53, 53, 53); font-family: 微软雅黑; font-size: 12.7559pt; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;把&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;“&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;接口&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt;”&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;理解为&lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: Verdana-Bold; font-weight: bold;&quot;&gt; OOP &lt;/span&gt;&lt;span style=&quot;font-size: 15.007pt; font-family: MicrosoftYaHei-Bold; font-weight: bold;&quot;&gt;中的接口概念：&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;理解成java中的interface。&lt;/div&gt;&lt;div&gt;接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="2670" y="4490" width="1040" height="430" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
