<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36" version="26.0.3">
  <diagram name="第 1 页" id="TzDZJ18uVH2BrXoznrYu">
    <mxGraphModel dx="1781" dy="1787" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="oE_ixGBvfXvZEjppzsO--1" value="分布式协调框架&lt;br&gt;ZAB(zk写用的协议，除了zk很少用了) RAFT(重点)&amp;nbsp; PAXIO(共识的有缺陷)" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="350" y="360" width="470" height="70" as="geometry" />
        </mxCell>
        <mxCell id="EsCJ1PF5g06sX3PIpRF--1" value="Zookeeper的客户端和服务端通信是怎么实现的？服务端和服务端呢？很多框架底层用的是Netty，而且Netty和Zk都是基于java开发的，为什么不用呢？难道zk出来的时候还没有netty？" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="370" y="480" width="330" height="130" as="geometry" />
        </mxCell>
        <mxCell id="aoBaY2fR4_1X0Lq2eARB-2" value="zookeeper大家用得最多得是临时节点 、watch监听机制。" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="370" y="640" width="330" height="130" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-1" value="ZK节点：持久节点、临时节点、有序节点（持久有序节点、临时有序节点）。&lt;div&gt;独有的监听机制。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;利用节点的特性和监听机制可以实现：分布式协调服务（分布式锁、集群管理（比如Hadoop集群））、分布式ID、分布式配置中心、分布式队列。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;节点间的普通数据通信（增删改查节点书）是用的Netty或者NIO，高一点的版本都是Netty了。但是节点间进行选举通信还是用的BIO，同时只允许服务器节点号大的节点发起socket连接，向小的发送（socket是全双工通信，这样可以减少创建连接的个数，优化性能）。首先，启动的时候，会对集群节点进行死循环，判断节点的状态，Looking，Follower，Master，Watcher，大概是这4个状态，观察者不进行选举。（3个节点组成集群，那么当启动2个节点之后，就能够选举出来Leader节点了，先看事务ID，选大的那个当Leader，如果都一样，看服务器ID，大的那个当选），如果是Looking，就会进行投票，票数超过一半的才会被选举为Leader，首先会投自己，那么第一轮肯定选举不出来结果，都只有自己1票。第二轮.....。同时选举发送选举票的架构还用到了很多队列，发送的时候把选举票交给一个发送队列，由发送线程进行处理。这个线程会根据发送目标来把发送消息处理到对应的队列中（每个节点都有一个对应的队列，为什么要这样做呢？这也算是一种资源隔离，一个出问题了，不影响其他的消息发送）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;paxos是最基础的共识算法，据说有缺陷？&amp;nbsp; 然后zk是在这个基础上进行改进成ZAB算法，后来，更简洁高效的Raft算法出来了。所以后面的很多中间件都是用的Raft算法（etcd，高版本的kafka也是基于raft实现的kraft）。&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;fontSize=18;fontStyle=1" vertex="1" parent="1">
          <mxGeometry x="220" y="-310" width="660" height="590" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-2" value="&lt;span style=&quot;color: rgba(0, 0, 0, 0.85); font-family: Inter, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;SF Pro SC&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, &amp;quot;SF Pro Icons&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space-collapse: preserve; background-color: rgba(0, 0, 0, 0.04);&quot;&gt;zk所有写请求都要经过主节点？读请求呢？如果是过半协议，5个节点，那么当一个写请求经过3个节点确认之后，就返回客户端成功。剩下2个节点可能会失败，这时候读请求，如果转发到了这2个节点，不是一样由数据一致性问题吗？&lt;/span&gt;&lt;div&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.85); font-family: Inter, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;SF Pro SC&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, &amp;quot;SF Pro Icons&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space-collapse: preserve; background-color: rgba(0, 0, 0, 0.04);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.85); font-family: Inter, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;SF Pro SC&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, &amp;quot;SF Pro Icons&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space-collapse: preserve; background-color: rgba(0, 0, 0, 0.04);&quot;&gt;ZAB协议就是干这个事情的，会保证数据一致性&lt;/span&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="-350" y="310" width="610" height="130" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-3" value="" style="shape=parallelogram;perimeter=parallelogramPerimeter;whiteSpace=wrap;html=1;fixedSize=1;" vertex="1" parent="1">
          <mxGeometry x="420" y="-110" width="120" height="60" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
