<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36" version="26.0.11">
  <diagram name="第 1 页" id="TzDZJ18uVH2BrXoznrYu">
    <mxGraphModel dx="3703" dy="3404" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="oE_ixGBvfXvZEjppzsO--1" value="分布式协调框架&lt;br&gt;ZAB(zk写用的协议，除了zk很少用了) RAFT(重点)&amp;nbsp; PAXIO(共识的有缺陷)" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="340" y="1450" width="470" height="70" as="geometry" />
        </mxCell>
        <mxCell id="EsCJ1PF5g06sX3PIpRF--1" value="Zookeeper的客户端和服务端通信是怎么实现的？服务端和服务端呢？很多框架底层用的是Netty，而且Netty和Zk都是基于java开发的，为什么不用呢？难道zk出来的时候还没有netty？" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="360" y="1570" width="330" height="130" as="geometry" />
        </mxCell>
        <mxCell id="aoBaY2fR4_1X0Lq2eARB-2" value="zookeeper大家用得最多得是临时节点 、watch监听机制。" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="360" y="1730" width="330" height="130" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-1" value="ZK节点：持久节点、临时节点、有序节点（持久有序节点、临时有序节点）。&lt;div&gt;独有的监听机制。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;利用节点的特性和监听机制可以实现：分布式协调服务（分布式锁、集群管理（比如Hadoop集群））、分布式ID、分布式配置中心、分布式队列。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;客户端-服务端交互是用的Netty或者NIO，高一点的版本都是Netty了。但是节点间进行选举通信、数据的一致性 还是用的BIO，同时只允许服务器节点号大的节点发起socket连接，向小的发送（socket是全双工通信，这样可以减少创建连接的个数，优化性能）。首先，启动的时候，会对集群节点进行死循环，判断节点的状态，Looking，Follower，Master，Watcher，大概是这4个状态，观察者不进行选举。（3个节点组成集群，那么当启动2个节点之后，就能够选举出来Leader节点了，先看事务ID，选大的那个当Leader，如果都一样，看服务器ID，大的那个当选），如果是Looking，就会进行投票，票数超过一半的才会被选举为Leader，首先会投自己，那么第一轮肯定选举不出来结果，都只有自己1票。第二轮.....。同时选举发送选举票的架构还用到了很多队列，发送的时候把选举票交给一个发送队列，由发送线程进行处理。这个线程会根据发送目标来把发送消息处理到对应的队列中（每个节点都有一个对应的队列，为什么要这样做呢？这也算是一种资源隔离，一个出问题了，不影响其他的消息发送）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;paxos是很复杂的算法，很难去实现。&amp;nbsp; 然后zk是在这个基础上进行改进成ZAB算法，后来，更简洁高效的Raft算法出来了。所以后面的很多中间件都是用的Raft算法（Nacos、etcd，高版本的kafka也是基于raft实现的kraft）&lt;font style=&quot;color: rgb(255, 0, 0);&quot;&gt;。Raft也是强一致性算法&lt;/font&gt;，不要弄成soft软的了。&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;fontSize=18;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="210" y="780" width="660" height="590" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-2" value="&lt;span style=&quot;color: rgba(0, 0, 0, 0.85); font-family: Inter, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;SF Pro SC&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, &amp;quot;SF Pro Icons&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space-collapse: preserve; background-color: rgba(0, 0, 0, 0.04);&quot;&gt;zk所有写请求都要经过主节点？读请求呢？如果是过半协议，5个节点，那么当一个写请求经过3个节点确认之后，就返回客户端成功。剩下2个节点可能会失败，这时候读请求，如果转发到了这2个节点，不是一样由数据一致性问题吗？&lt;/span&gt;&lt;div&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.85); font-family: Inter, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;SF Pro SC&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, &amp;quot;SF Pro Icons&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space-collapse: preserve; background-color: rgba(0, 0, 0, 0.04);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.85); font-family: Inter, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;SF Pro SC&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, &amp;quot;SF Pro Icons&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space-collapse: preserve; background-color: rgba(0, 0, 0, 0.04);&quot;&gt;ZAB协议就是干这个事情的，会保证数据一致性？ 查询应该会去找事务ID，如果不是最新的事务ID，就会去主节点同步数据。这样会不会耗性能呀？&lt;/span&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-360" y="1400" width="610" height="130" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-4" value="&lt;span style=&quot;color: rgba(0, 0, 0, 0.85); font-family: Inter, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;SF Pro SC&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, &amp;quot;SF Pro Icons&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space-collapse: preserve; background-color: rgba(0, 0, 0, 0.04);&quot;&gt;在Redis CLuster集群内部，节点之间通过 Gossip 协议进行通信，用于交换节点状态、故障检测等信息。 众所周知，cluster集群，每个主节点，也可以弄几个从节点，那Gossip 协议通信，是指的所有主从节点？还是只由主节点进行通信？怎么选举主节点的呢？&lt;/span&gt;&lt;div&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.85); font-family: Inter, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;SF Pro SC&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, &amp;quot;SF Pro Icons&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space-collapse: preserve; background-color: rgba(0, 0, 0, 0.04);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.85); font-family: Inter, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;SF Pro SC&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, &amp;quot;SF Pro Icons&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space-collapse: preserve;&quot;&gt;&lt;ol style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); margin-bottom: 0px; padding-left: 20px; overflow-anchor: auto; color: rgb(34, 34, 34); font-size: 16px; white-space-collapse: collapse; margin-top: 0px !important;&quot; class=&quot;auto-hide-last-sibling-br&quot;&gt;&lt;li style=&quot;background-color: light-dark(rgb(255, 255, 255), rgb(18, 18, 18)); -webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); list-style-type: decimal; padding-left: 4px; overflow-anchor: auto; color: var(--md-box-samantha-normal-text-color) !important;&quot;&gt;&lt;div style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); line-height: var(--md-box-samantha-normal-text-line-height); margin-bottom: 0px; margin-top: 0px; font-size: var(--md-box-samantha-normal-text-font-size); color: initial; overflow-anchor: auto;&quot; class=&quot;auto-hide-last-sibling-br paragraph-JOTKXA paragraph-element br-paragraph-space&quot;&gt;&lt;span style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-weight: 600; color: initial; font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); overflow-anchor: auto;&quot;&gt;Gossip 协议涉及的节点范围&lt;/span&gt;&lt;/div&gt;&lt;ul style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); margin-bottom: 0px; margin-top: 8px; overflow-anchor: auto; color: initial; padding-left: 20px !important;&quot; class=&quot;auto-hide-last-sibling-br&quot;&gt;&lt;li style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); color: initial; list-style-type: circle; padding-left: 4px; overflow-anchor: auto;&quot;&gt;&lt;span style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-weight: 600; color: initial; font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); overflow-anchor: auto;&quot;&gt;所有主从节点参与&lt;/span&gt;：在 Redis Cluster 中，Gossip 协议用于所有主从节点之间的通信。每个节点（包括主节点和从节点）都会定期与其他部分节点交换信息。这种信息交换包括节点的状态（如是否存活、是否处于故障恢复阶段等）、数据分片（哈希槽）的分配情况以及集群的拓扑结构变化等内容。&lt;/li&gt;&lt;li style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); color: initial; list-style-type: circle; margin-top: 8px; padding-left: 4px; overflow-anchor: auto;&quot;&gt;&lt;span style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-weight: 600; color: initial; font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); overflow-anchor: auto;&quot;&gt;信息传播机制&lt;/span&gt;：通过 Gossip 协议，节点会随机选择一些其他节点来发送自己所知道的信息，同时接收来自其他节点的信息。接收信息的节点会更新自己对集群状态的认知，并将这些信息继续传播给其他节点。这样，集群中的信息会以一种类似 “流言蜚语” 的方式在整个集群中逐渐扩散，使得所有节点都能在一定时间内了解到集群的最新状态。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); list-style-type: decimal; margin-top: 8px; padding-left: 4px; overflow-anchor: auto; color: var(--md-box-samantha-normal-text-color) !important;&quot;&gt;&lt;div style=&quot;background-color: light-dark(rgb(255, 255, 255), rgb(18, 18, 18)); -webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); line-height: var(--md-box-samantha-normal-text-line-height); margin-bottom: 0px; margin-top: 0px; font-size: var(--md-box-samantha-normal-text-font-size); color: initial; overflow-anchor: auto;&quot; class=&quot;auto-hide-last-sibling-br paragraph-JOTKXA paragraph-element br-paragraph-space&quot;&gt;&lt;span style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-weight: 600; color: initial; font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); overflow-anchor: auto;&quot;&gt;Redis Cluster 主节点选举机制&lt;/span&gt;&lt;/div&gt;&lt;ul style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); margin-bottom: 0px; margin-top: 8px; overflow-anchor: auto; color: initial; padding-left: 20px !important;&quot; class=&quot;auto-hide-last-sibling-br&quot;&gt;&lt;li style=&quot;background-color: light-dark(rgb(255, 255, 255), rgb(18, 18, 18)); -webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); color: initial; list-style-type: circle; padding-left: 4px; overflow-anchor: auto;&quot;&gt;&lt;span style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-weight: 600; color: initial; font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); overflow-anchor: auto;&quot;&gt;故障检测与投票&lt;/span&gt;：当一个主节点出现故障时，它的从节点会发现与主节点的连接中断。从节点会等待一段时间（可配置的故障转移等待时间），以确定主节点是否真的出现故障。如果在等待时间结束后仍然无法与主节点重新连接，从节点会发起选举流程。&lt;/li&gt;&lt;li style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); color: initial; list-style-type: circle; margin-top: 8px; padding-left: 4px; overflow-anchor: auto;&quot;&gt;&lt;span style=&quot;background-color: light-dark(rgb(255, 255, 255), rgb(18, 18, 18)); -webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-weight: 600; color: initial; font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); overflow-anchor: auto;&quot;&gt;选举条件和投票规则&lt;/span&gt;：在选举过程中，从节点会向集群中的其他主节点发送投票请求。主节点会根据一定的规则进行投票，例如，主节点会优先投票给复制偏移量（replication offset）最大的从节点，因为复制偏移量代表了从节点数据的完整性和更新程度。一个从节点需要获得集群中大多数主节点（&lt;span style=&quot;background-color: rgb(255, 0, 0);&quot;&gt;超过半数&lt;/span&gt;）的选票才能当选为新的主节点。&lt;/li&gt;&lt;li style=&quot;background-color: light-dark(rgb(255, 255, 255), rgb(18, 18, 18)); -webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); color: initial; list-style-type: circle; margin-top: 8px; padding-left: 4px; overflow-anchor: auto;&quot;&gt;&lt;span style=&quot;-webkit-font-smoothing: antialiased; box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); --desktop-home-page-background-color: light-dark(#f4f4f4, #1b1b1b); --desktop-home-card-background-color: light-dark(#fdfdfd, #141414); --desktop-home-card-background-color-hover: light-dark(#fff, #000000); --desktop-home-popup-background-color: light-dark(#f6f5f5, #1a1a1a); font-weight: 600; color: initial; font-size: var(--md-box-samantha-normal-text-font-size); line-height: var(--md-box-samantha-normal-text-line-height); overflow-anchor: auto;&quot;&gt;选举成功后的角色转换&lt;/span&gt;：当一个从节点获得足够的选票当选为新的主节点后，它会开始承担主节点的职责，包括处理写操作、管理哈希槽等。同时，集群中的其他节点会更新它们对集群拓扑结构的认知，将新的主节点纳入正常的工作流程中。这种选举机制确保了在主节点出现故障时，集群能够快速地恢复服务，并且选择一个数据状态相对较新的节点来继续提供服务。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/span&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-370" y="1580" width="670" height="590" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-5" value="&lt;div&gt;&lt;span style=&quot;font-size: 12.0111pt; font-family: 微软雅黑; color: rgb(223, 64, 42);&quot;&gt;ZooKeeper本质上是一个分布式的小文件存储系统（Zookeeper=文件系统+监听机制）。&lt;/span&gt;&lt;span style=&quot;color: rgb(243, 50, 50); font-family: 微软雅黑; font-size: 12.0111pt; background-color: transparent;&quot;&gt;可以达到基于数据的集群管理、统&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 12.0111pt; font-family: 微软雅黑; color: rgb(243, 50, 50);&quot;&gt;一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 12.0111pt; font-family: 微软雅黑;&quot;&gt;Zookeeper从设计模式角度来理解：&lt;/span&gt;&lt;span style=&quot;font-size: 12.0111pt; font-family: 微软雅黑; color: rgb(223, 64, 42);&quot;&gt;是一个基于观察者模式设计的分布式服务管理框架&lt;/span&gt;&lt;span style=&quot;font-size: 12.0111pt; font-family: 微软雅黑;&quot;&gt;，&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 12.0111pt; font-family: 微软雅黑;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 12.0111pt; font-family: 微软雅黑; color: rgb(223, 64, 42);&quot;&gt;leader节点可以处理读写请求，follower只可以处理读请求。follower在接到写请求时会把写请求转发&lt;/span&gt;&lt;span style=&quot;color: light-dark(rgb(223, 64, 42), rgb(255, 126, 107)); font-family: 微软雅黑; font-size: 12.0111pt; background-color: transparent;&quot;&gt;给leader来处理。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 12.0111pt; font-family: 微软雅黑; color: rgb(223, 64, 42);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-family: 微软雅黑; color: rgb(223, 64, 42);&quot;&gt;&lt;div style=&quot;font-size: 12.0111pt;&quot;&gt;&lt;span style=&quot;font-size: 12.0111pt; color: rgb(0, 0, 0);&quot;&gt;Zookeeper数据一致性保证：这是防止多个客户端同时对一个节点进行操作。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 12.0111pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5097pt; color: rgb(0, 0, 0);&quot;&gt;全局可线性化(Linearizable )写入∶先到达leader的写请求会被先处理，leader决定写请求的执行顺序。&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 12.0111pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5097pt; color: rgb(0, 0, 0);&quot;&gt;客户端FIFO顺序∶来自给定客户端的请求按照发送顺序执行。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 12.0111pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5097pt; color: rgb(0, 0, 0);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;&lt;div style=&quot;font-size: 10.5097pt;&quot;&gt;&lt;span style=&quot;font-size: 12.0111pt; color: rgb(243, 50, 50);&quot;&gt;ZooKeeper的Leader选举过程是基于投票和对比规则的&lt;/span&gt;&lt;span style=&quot;font-size: 12.0111pt;&quot;&gt;，&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 10.5097pt;&quot;&gt;&lt;span style=&quot;font-size: 12.0111pt;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 10.5097pt;&quot;&gt;&lt;span style=&quot;font-size: 12.0111pt;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16.0148px;&quot;&gt;ZK的客户端 Curator，可以看看源码,CountDownLatch有用到。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16.0148px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16.0148px;&quot;&gt;Redis其实高可用都需要有主从集群，数据都是异步复制过去的。所以它是AP架构。CLuster 集群间(包括所有的主从)，都是Gossip协议通信，这个其实不算一致性协议算法，算是分布式系统中的信息传播协议，一致性协议算法主要有（Paxos、Zab、Raft）。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16.0148px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16.0148px;&quot;&gt;Redis的主从复制不需要过半协议，它是异步的。所以性能才高。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16.0148px;&quot;&gt;但是redis cluster的选举，是需要过半机制的，但是这个机制不是典型的一致性协议。这里可能还要多理解了。。。&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-480" y="770" width="590" height="530" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-6" value="" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-1250" y="940" width="750" height="190" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-7" value="Redis CLuster Node 1&lt;div&gt;Master&lt;/div&gt;" style="ellipse;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-1150" y="940" width="160" height="80" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-8" value="Redis CLuster Node 2&lt;div&gt;Master&lt;/div&gt;" style="ellipse;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-900" y="940" width="160" height="80" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-9" value="Redis CLuster Node 3&lt;div&gt;Master&lt;/div&gt;" style="ellipse;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-690" y="940" width="160" height="80" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-13" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="a138Q77CWcjG1b8q-LW_-10" target="a138Q77CWcjG1b8q-LW_-7" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-10" value="Redis CLuster Node 1&lt;div&gt;slaver1&lt;/div&gt;" style="ellipse;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-1250" y="1040" width="160" height="80" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-14" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="a138Q77CWcjG1b8q-LW_-11" target="a138Q77CWcjG1b8q-LW_-7" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-11" value="Redis CLuster Node 1&lt;div&gt;slaver2&lt;/div&gt;" style="ellipse;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-1050" y="1040" width="160" height="80" as="geometry" />
        </mxCell>
        <mxCell id="a138Q77CWcjG1b8q-LW_-12" value="......." style="ellipse;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-770" y="1035" width="160" height="80" as="geometry" />
        </mxCell>
        <mxCell id="IuTUAlNMjMsG8cdk08z8-1" value="ZK关注的点：Leader选举、数据主从同步、Watcher机制。&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;其中ZAB协议包括了leader选举 和 数据的主从同步规则。主从数据同步基于二阶段提交来的。其中Leader发送之后，也会有一个ack，这样才能保证半数提交。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;事务ID，是由2部分组成的：高32位是 根据AutomicLong来进行获取的自增Long值，低32位是选举的轮数。 因为生成事务ID是在主节点进行的。从0开始递增。那么如果当主节点挂掉了之后，从节点选举成主节点，也要开始从0递增，那么就可能重复，所以高32位的选举轮数就产生了作用了，防止出现重复。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;客户端发送创建节点到服务端主节点，主节点收到后先保存到文件里面，创建一个责任链处理逻辑。然后发送bio请求（包含创建的消息，事务ID等）给从节点，从节点也有对应的责任链模式。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2阶段提交：这是针对服务端的主节点向从节点提交客户端发来的写命令。首先主节点先保存到自己的文件里，然后发送消息+事务ID给从节点，从节点收到后返回ack给主节点（事务ID），主节点收到消息，确认是否过半，过半后操作数据到自己的内存，然后再发送一个commit给从节点（只有事务ID）,从节点收到提交消息后，从本地文件里获取数据，操作到内存里面。再次返回ack？&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;fontSize=18;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="960" y="800" width="660" height="590" as="geometry" />
        </mxCell>
        <mxCell id="2IypcNXVYgAPfPnaSOmg-1" value="ZK源码：&lt;div&gt;1.下载源码：https://github.com/apache/zookeeper&amp;nbsp; &amp;nbsp;选择分支版本：3.5.8&lt;/div&gt;&lt;div&gt;2.直接用idea打开，是一个maven项目，在根目录执行：mvn clean install -DskipTests&lt;/div&gt;&lt;div&gt;3.找到服务端的启动类：在/bin文件夹下面，打开zkServer.sh 或者cmd文件，里面有项目启动类的信息：org.apache.zookeeper.server.quorum.QuorumPeerMain&lt;/div&gt;&lt;div&gt;3.复制/config文件夹下面的&amp;nbsp;zoo_sample.cfg 配置文件，改名为zoo.cfg，修改里面的 dataDir 配置到根路径的data文件夹的data文件夹（自己新建），然后再idea里面去找到启动类，修改启动&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;配置&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;文件，把zoo.cfg的目录配置到 Program arguments里面：&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;D:\GitHub\ZK\zk-3.5.8\zookeeper\conf\zoo.cfg&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;4.将pom文件里面的scope为provide的这行全部注释掉，jline的除外。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;5.直接run这个启动类，可能会发生报错：&lt;/div&gt;&lt;div&gt;java.io.IOException: Failed to bind to /0.0.0.0:8080&lt;/div&gt;&lt;div&gt;Caused by: java.net.BindException: Address already in use: bind&lt;/div&gt;&lt;div&gt;这个错误就是启动Jetty的时候，8080端口被占用了。&lt;/div&gt;&lt;div&gt;解决：在zoo.cfg配置文件中添加配置：&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;admin.serverPort=6088&amp;nbsp; &amp;nbsp;修改启动的端口就行了。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;如何用客户端连接：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;代码里面，找到客户端主类&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;ZooKeeperMain，然后修改启动配置，&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;Program arguments里面：&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;-server localhost:2181&amp;nbsp; &amp;nbsp;，然后运行即可。&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;idea里面启动客户端，打出来的日志太多了，如何修改日志级别呢？&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;在conf文件夹里面拷贝一个logback.xml----&amp;gt;&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;logback-cli.xml。然后修改最后的&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&amp;lt;root level=&quot;ERROR&quot;&amp;gt;，再在Idea里面修改启动配置：Add VM Options：&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;-Dlogback.configurationFile=D:/GitHub/ZK/zk-3.5.8/zookeeper/conf/logback-cli.xml&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;集群如何启动：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;1.复制3个配置文件zoo1.cfg、zoo2.cfg、zoo3.cfg。需改dataDir配置（data1文件夹等等），admin.serverPort 配置、clientPort配置，每个机器都不一样。然后再最后加上配置：&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;server.1=127.0.0.1:2888:3888&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;server.2=127.0.0.1:2889:3889&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;server.3=127.0.0.1:2890:3890&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;2.在创建的dataDir对应的文件夹下面，每个都加一个myid文件（可以用idea创建），里面的内容就是server.1的这个1。&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;3.Idea里面复制3个启动配置文件&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;QuorumPeerMain1、2、3&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;，分别指向不同的配置文件&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;zoo1、2、3.cfg&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;4.先启动&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;QuorumPeerMain1，会报错：&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;Cannot open channel to 2 at election address /127.0.0.1:3889&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;然后启动&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;QuorumPeerMain2，就停止报错，并且在Main1里面打印出日志：&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;Peer state changed: following - broadcast。&amp;nbsp; 在Main2里面打印出日志：&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;Peer state changed: leading - broadcast，说明选举成功，节点1是从节点，节点2是主节点，之后再启动节点3，也是一个从节点。&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;ZK源码里面的一些类定义的意义：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;Quorum：法定人数、多数。在Zk中的意思是，达成一致决策所需的最小节点数量。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;Peer：伙伴。在Zk中，集群中的每个节点都可以看做是一个Peer伙伴，地位是平等的。&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;Cnx：Connection 连接的缩写。&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;Vote：投票。&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color: transparent;&quot;&gt;QuorumCnxManager：这个应该是说的集群节点之间连接的管理器。&lt;/span&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;fontSize=18;fontStyle=1;fillColor=#fff2cc;strokeColor=#d6b656;" parent="1" vertex="1">
          <mxGeometry x="-610" y="-1400" width="960" height="1040" as="geometry" />
        </mxCell>
        <mxCell id="2IypcNXVYgAPfPnaSOmg-2" value="Leader启动选举的过程：&lt;div&gt;前提：发起选票的格式：myid+最大事务ID+当前选举的轮数，配置文件中的&amp;nbsp;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;server.1=127.0.0.1:2888:3888，这个server后面的就是myid，跟哪个机器关联，然后有2个端口，3888端口就是选票用的端口，用来接收别的机器发送过来的选票。2888是服务端节点间进行数据通信的端口。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;每个机器启动的时候，先投自己的票，然后发给另外的机器。（myid1，0），具体流程看文档。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;Leader选举算法，elctionType默认为3：FastLeaderElection&lt;/span&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;fontSize=18;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="-1220" y="-290" width="660" height="590" as="geometry" />
        </mxCell>
        <mxCell id="90wm_4bqXWY0LaqGxaO0-1" value="总结ZK：&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;zk是一个分布式协调框架。提供了：分布式配置管理、分布式命名服务、分布式锁、分布式队列等功能。不适合存储大量的数据。是一个CP架构。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;zk的cp集群架构，启动的时候，肯定是先要选举一个Leader出来，&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;fontSize=18;fontStyle=1" vertex="1" parent="1">
          <mxGeometry x="-1430" y="-1174" width="660" height="590" as="geometry" />
        </mxCell>
        <mxCell id="90wm_4bqXWY0LaqGxaO0-2" value="ZK的客户端是怎么做的？用到了JUC的类，然后是怎么分发请求到哪个节点的？是不是判断了读写请求的？" style="text;html=1;align=left;verticalAlign=top;whiteSpace=wrap;rounded=0;fontSize=18;" vertex="1" parent="1">
          <mxGeometry x="-1220" y="-1390" width="260" height="120" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
