<mxfile host="app.diagrams.net" modified="2023-12-12T05:12:08.513Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36" etag="hTYQMSzu7S5Tf6BRpZMz" version="22.1.7" type="github">
  <diagram name="第 1 页" id="L6XU-YJSm6NN8EeBNm4k">
    <mxGraphModel dx="1434" dy="1927" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="aYSDuqsWhtXODDXYn9be-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;为什么使用B+树作为存储数据结构呢？普通二叉树、B树、红黑树为什呢不行？&lt;br&gt;跳表跟B+树的区别是什么？&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;&lt;span style=&quot;&quot;&gt;Mysql为什么用B+树不用跳表？&lt;/span&gt;&lt;br&gt;&lt;br&gt;B+树结构和B树结构的区别？它们的叶子结点和非叶子结点存储的是什么？&lt;br&gt;&lt;br&gt;哈希索引的优劣势是什么？&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="20" y="20" width="780" height="210" as="geometry" />
        </mxCell>
        <mxCell id="aYSDuqsWhtXODDXYn9be-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;Mysql有2中存储引擎分别是什么？物理结构上如何区分？逻辑结构上有什么不同？&lt;br&gt;&lt;br&gt;Mysql中为什么要建议搞一个连续递增的主键呢？如果没有主键，数据库会先从列中找一个没有重复数据的列作为主键，如果没有满足的列，那么就会自己维护一个隐藏自增列作为主键？&lt;br&gt;&lt;br&gt;如果不是连续递增的，那么维护B+树的时候，插入就很麻烦了，就会频繁进行大量的调整，影响效率。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="44" y="240" width="836" height="170" as="geometry" />
        </mxCell>
        <mxCell id="aYSDuqsWhtXODDXYn9be-3" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;聚簇索引和非聚簇索引的区别？&lt;br&gt;&lt;br&gt;二级索引是什么意思？二级索引回表操作是什么意思？二级索引的叶子结点存的是什么？&lt;br&gt;&lt;br&gt;这里我们说的回表，指的是索引回表，除了索引回表，还有哪些操作可能会回表呢？&lt;br&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;回表也可以叫做 二次查找、二次检索。除了索引回表之外，还有连接回表，子查询回表。后面2个，是因为如果要获取连接表的列数据或者子查询表的结果时，就会进行回表。&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;font color=&quot;#0000ff&quot;&gt;回表为什么说是随机IO呢？随机IO和顺序IO的区别是什么？为什么顺序IO的效率要高很多呢？要避免回表？为什么随机IO的效率慢？慢在哪里了？&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;font color=&quot;#ff0000&quot;&gt;不仅仅回表是随机IO，而且普通的索引查询，如果走的是磁盘，也是随机IO。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;区别：随机IO，因为数据在磁盘上不是连续存储的，所以需要进行磁头寻道和磁盘旋转等操作。这些操作比较耗时，而顺序IO，因为是连续的存储在磁盘上，不需要这些耗时。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;注意：如果想要在新建一个文件里面实现顺序IO，那么必须要事先指定文件大小，好让文件提前占着磁盘的位置，这样才能顺序IO。&lt;br&gt;&lt;br&gt;Kafka之所以能够高效的进行磁盘读写，部分原因就是顺序IO：采用分段日志，每段日志固定大小，预先分配磁盘空间，采用消息追加的方式&lt;/font&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="44" y="420" width="756" height="480" as="geometry" />
        </mxCell>
        <mxCell id="DzlcBEAfJtIRjQRNxWo9-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;Explain的使用&lt;br&gt;&lt;br&gt;Mysql的成本分析（执行一个sql开启显示成本分析），具体的分析算法是怎样的？&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry y="1570" width="740" height="120" as="geometry" />
        </mxCell>
        <mxCell id="PFGi73NgZuRSLPyA7w7K-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;联合索引（包括联合主键索引）是什么？&lt;br&gt;&lt;br&gt;覆盖索引是什么？走二级索引一定比主键索引慢吗？走二级索引一定会进行回表吗？&lt;br&gt;&lt;br&gt;不一定的。如果查询的字段刚好二级索引（这里建立的是联合索引的二级索引）包含完了，那么就不会回表。而且因为二级索引跟主键索引比，不包含所有的字段数据。那可能查询起来就快一些。直接把B+树整体拿到内存里面查找。&lt;br&gt;&lt;br&gt;分析出来会走索引，数据库就一定会走索引吗？&lt;br&gt;其实不然，数据库自己还有优化，万一数据库觉得走全表扫描比走索引还快的话，就不会走索引了。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="10" y="1070" width="776" height="270" as="geometry" />
        </mxCell>
        <mxCell id="PFGi73NgZuRSLPyA7w7K-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;索引是什么？&lt;br&gt;&lt;br&gt;牢记索引是一种排好序的数据结构！且B+数的索引叶子结点包含了全部数据信息（二级索引除外）。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="44" y="-160" width="740" height="150" as="geometry" />
        </mxCell>
        <mxCell id="PFGi73NgZuRSLPyA7w7K-3" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;其实所有的优化原则的原理，根据下面这句宗旨去进行分析就很好理解：就记住B+树索引是排好序的数据结构，并且叶子节点包含了所有列的数据（二级索引存的是主键信息，会进行回表查询）。&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;比如：最左匹配，不能给索引列加函数方法，like的百分号要在右边。&lt;br&gt;&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;怎么分析呢？&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;最左匹配：因为索引是排好序的，比如 联合索引 name,age 。索引的排序是先按照name进行排序，如果name有相同的，再根据age进行排序。那如果你的where条件是age在前面，那怎么能找得到呢。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="10" y="1350" width="830" height="170" as="geometry" />
        </mxCell>
        <mxCell id="r750OqilGSKwBD_I3ron-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;索引下推是什么？&lt;br&gt;&lt;br&gt;mysql什么情况下回用到索引下推呢？&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="900" y="910" width="830" height="170" as="geometry" />
        </mxCell>
        <mxCell id="r750OqilGSKwBD_I3ron-3" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;一条sql是如何在mysql中执行的呢？&lt;br&gt;&lt;br&gt;mysql有哪些角色？&lt;br&gt;&lt;br&gt;词法分析器有哪些步骤？&lt;br&gt;&lt;br&gt;语法分析生成一个语法树，这个东西有什么意义，能使用在哪些方面呢？&lt;br&gt;分库分表：java有类库可以支持生成语法树，然后我们可以根据这个树，来判断走哪个库哪个表。&lt;br&gt;分布式事务回滚：&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="10" y="1760" width="840" height="240" as="geometry" />
        </mxCell>
        <mxCell id="MdRjEa7SP88yfNxcg5VE-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;索引如何优化呢？&lt;br&gt;&lt;br&gt;索引的建立是根据业务需求理解慢慢的来建立，慢慢的来优化的。不是凭脑袋空想！&lt;br&gt;&lt;br&gt;要充分利用联合索引，一张表可以建立2-3个联合索引，根据业务来决定。&lt;br&gt;&lt;br&gt;区间范围查找的字段要放在最后面。如果有多个区间范围查找，那么看看能不能优化，比如把age&amp;gt;20 and age &amp;lt;30 的这种范围sql优化成 age in (20,21...,30)。&lt;br&gt;&lt;br&gt;因为多个字段进行范围查找的话，可能只有第一个字段能走索引，后面的都不能走了。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1310" y="-90" width="810" height="240" as="geometry" />
        </mxCell>
        <mxCell id="MdRjEa7SP88yfNxcg5VE-2" value="下面的sql在39上面执行，要花费2分多钟。&lt;br&gt;去掉药品表的distinct之后，就只要70ms了。&lt;br&gt;&lt;br&gt;SELECT pat.mhiscode, pat.taskid, pat.caseid, pat.patientid, task.auditmodeid, mednum, recipetypecodeex, recipetypecode, recipetypename, reciperoutename, reciperoutecode, ordernum as index, frequency, singledose, num, numunit, druguniquecode, drugname, doseunit, duration, task.starttime, doctorcode, doctorname, deptcode, deptname, drug.prescno as presno, 1 as sourceType FROM pr.clinic_pat_info pat JOIN pr.clinic_task_info_history task ON pat.taskid = task.taskid AND pat.mhiscode = task.mhiscode JOIN(SELECT taskid, auditmodeid, max(sendtime) AS sendtime FROM pr.clinic_task_info_history WHERE taskid BETWEEN 202309160000000000 AND 202309230000000000 AND status &amp;gt;= 0 and status &amp;lt;&amp;gt; ANY(ARRAY[12, 24, 25, 26]) GROUP BY taskid, auditmodeid) history ON task.taskid = history.taskid AND task.auditmodeid = history.auditmodeid AND task.sendtime = history.sendtime JOIN (SELECT DISTINCT taskid, prescno, drugindex, ordernum, frequency, singledose, num, numunit, doseunit, duration FROM pr.clinic_pat_drug_order WHERE taskid BETWEEN 202309160000000000 AND 202309230000000000 AND ordertype &amp;lt;&amp;gt; ANY(ARRAY[1, 2])) drug ON history.taskid = drug.taskid LEFT JOIN (select * from pr.clinic_pat_recipe where taskid between 202309160000000000 AND 202309230000000000) recipe ON drug.taskid = recipe.taskid AND drug.prescno = recipe.prescno LEFT JOIN pr.drug_index index ON drug.drugindex = index.drugindex WHERE pat.taskid BETWEEN 202309160000000000 AND 202309230000000000 AND task.taskid BETWEEN 202309160000000000 AND &lt;br&gt;202309230000000000 AND task.status &amp;gt;= 0 and task.status &amp;lt;&amp;gt; ANY(ARRAY[12, 24, 25, 26]) ORDER BY task.taskid, task.sendtime" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1320" y="250" width="910" height="220" as="geometry" />
        </mxCell>
        <mxCell id="X4JwkC8u1-y5Jrn2BpA5-1" value="select * from tableA where id in (select id from tableA where name =xxx and 。。。)&lt;br&gt;select * froom tableA as a inner join (select id fromtableA where name =xxx and 。。。) as b on&amp;nbsp; a.id = b.id&lt;br&gt;这种 in 和join的效率相比咋样（可能子查询的条数多了之后，就不会走主键索引了？可能mysql认为全表扫描比索引还快点？）？2个sql都是用到了二级索引，缩小了记录条数，然后再查找所有的字段。" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1440" y="560" width="640" height="90" as="geometry" />
        </mxCell>
        <mxCell id="X4JwkC8u1-y5Jrn2BpA5-2" value="inner join on 条件的指定，走索引和不走索引的区别是什么？&lt;br&gt;&lt;br&gt;各种join的原理是什么？&lt;br&gt;&lt;br&gt;小表 inner join 大表&amp;nbsp; &amp;nbsp;pk&amp;nbsp; &amp;nbsp; 大表&amp;nbsp; inner join 小表&amp;nbsp; &amp;nbsp;的区别？&lt;br&gt;&lt;br&gt;join on 有没有走索引的区别？&lt;br&gt;&lt;br&gt;count(*)、count(1)、count(二级索引)、count(主键)、count(没有索引) 之前的效率区别?&lt;br&gt;&lt;br&gt;阿里巴巴的mysql规范。" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1390" y="710" width="650" height="190" as="geometry" />
        </mxCell>
        <mxCell id="1pvLfjOu5_eiv0kYw-xj-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;MVCC机制原理：&lt;br&gt;跟事务隔离级别的关系？&lt;br&gt;&lt;br&gt;Buffer Pool跟redo log、undolog、binlog之间的关系，以及一条sql如何执行的关系。流程图，先undo--&amp;gt;redo---&amp;gt;binlog。&lt;br&gt;&lt;br&gt;redolog是用来恢复Buffer Pool里面的数据的。&lt;br&gt;binlog是用来恢复磁盘里面的数据的。&lt;br&gt;&lt;br&gt;为什么要有Buffer Pool？&lt;br&gt;其实很多中间件都有这个玩意儿，目的就是为了防止频繁的进行文件IO操作，影响效率。内存的操作速度是文件IO的多少次方倍。&lt;br&gt;&lt;br&gt;既然IO操作费时间，那么为什么事务的流程里面还要写这么多的日志呢？这个难道不费时间吗？&lt;br&gt;这里就是顺序IO和随机IO的区别了。这个差距是很大的，我们写日志是顺序IO，但是直接写数据的话，就是随机读写了。这跟Kafka有点像。&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="20" y="2060" width="1020" height="360" as="geometry" />
        </mxCell>
        <mxCell id="DgoiZzh3QHl1QlPg7UnV-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;InnoDB的3大特性（与事务无关）：自适应hash...&lt;br&gt;&lt;br&gt;MyIsam为什么都是稀疏索引？&lt;br&gt;&lt;br&gt;B+树为什么说3层效率最高？如果一行记录是1kb，那么3层B+树最多可以存储2500W行记录？这个是怎么计算的？&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="850" y="670" width="520" height="150" as="geometry" />
        </mxCell>
        <mxCell id="DgoiZzh3QHl1QlPg7UnV-3" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;三星索引是什么？&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="890" y="1920" width="450" height="130" as="geometry" />
        </mxCell>
        <mxCell id="TDYWAo7VMzj91rLCB7Ix-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;索引合并是什么？&lt;br&gt;如果有多个二级索引，Mysql只会用一个二级索引。但是可能优化器会进行索引合并。&lt;br&gt;按道理说索引合并会比单个二级索引多一些回表操作，就多一些随机IO，效率更低才对。&lt;br&gt;但是一切说效率都要跟数据量挂钩。Mysql进行成本分析之后，觉得有必要才进行索引合并。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="480" y="2500" width="770" height="120" as="geometry" />
        </mxCell>
        <mxCell id="9TrS2JWGWcBnD62vof_O-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;子查询Mysql的优化：&lt;br&gt;如果可以会先优化成半连接查询（Mysql内部的），为什么不是inner join，因为in不关注In里面的sql记录条数，只在乎有没有。这是逻辑上的一种区别？&lt;br&gt;还会优化成exist&lt;br&gt;也会优化成内存形式&lt;br&gt;也会优化成临时表形式&lt;br&gt;&lt;br&gt;以上的这些优化顺序是怎样的，跟Mysql版本有什么关系？&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="390" y="2750" width="800" height="200" as="geometry" />
        </mxCell>
        <mxCell id="9TrS2JWGWcBnD62vof_O-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;InnoDB的是怎么存储行记录的，格式是什么？怎么存储索引的？&lt;br&gt;&lt;br&gt;InnoDB的底层结构&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="370" y="3020" width="750" height="90" as="geometry" />
        </mxCell>
        <mxCell id="dTx3rwTkO2r90H_nULGv-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;从页、数据底层存储来解释为什么主键索引最好是递增的？&lt;br&gt;&lt;br&gt;操作系统每次跟磁盘获取数据的大小和mysql存储页的大小区别？&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;操作系统写文件以4kb为单位，mysql页面大小一般为16kb。&lt;br&gt;&lt;br&gt;Buffer Pool 和 doublewrite buffer 的区别？&lt;br&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;Buffer Pool是Mysql的内存缓存，用来存储表数据和索引的数据页，提高查询性能。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;doublewrite buffer是一种机制，用于保护InnoDb引擎下，断电或者崩溃下的数据完整性。&lt;br&gt;&lt;br&gt;doublewrite buffer 真正实现了事务的持久性。在这之前是有可能会丢失数据的。那么是如何进行数据完整性的呢？&lt;br&gt;&lt;br&gt;在什么情况下可以关闭掉doublewrite buffer以提高性能（5-10%）?&amp;nbsp; &amp;nbsp;主从复制中的从库。&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="380" y="3227" width="810" height="433" as="geometry" />
        </mxCell>
        <mxCell id="N1tSuVbC6mHXAO_MOer2-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;事务的4大特性实现原理：&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="330" y="3770" width="750" height="90" as="geometry" />
        </mxCell>
        <mxCell id="ICJE7UBgEt_on30tJHNk-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;Mysql高可用集群的演进&lt;br&gt;&lt;br&gt;1.主从集群：配置主和从节点的配置文件即可。主要是开通bin日志，它们同步数据的方式就是通过bing日志。主节点还可配置哪些库可以记录binlog日志，哪些库不能记录bin日志。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;除了bin日志同步，还有GTID同步：全局事务ID，最小单位是事务。&lt;br&gt;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;主从扩容：多增加一台从节点，因为bin日志是有时效性的，如果已经运行一段时间之后，Bin日志可能不全，所以需要通过sql备份，再还原，再进行主从同步。&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;mysqldump -u root -p --all-databases &amp;gt; backup.sql&amp;nbsp;&lt;br&gt;&lt;span style=&quot;&quot;&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;mysql -u root -p &amp;lt; backup.sql&lt;br&gt;&lt;br&gt;2.多主集群（多主+主从）、互主集群：多主其实也算是互主集群中的一种，主节点的my.ini文件下面，配置从节点的配置，指向从节点，可以复制从节点的修改数据。&lt;br&gt;&lt;br&gt;&lt;br&gt;3.半同步复制、全同步复制：主从集群之间的数据同步，是主节点fork一个子进程来进行socket发送sql数据。网络是不可靠的，这样是很容易丢失数据的。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;半同步：在发送给从节点之后，要等待从节点写入relay-log之后，从节点发出一个ack，主节点收到ack之后才会返回客户端。会有一个10s超时，多久没收到也会返回，不会一直等待。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;lib/plugin目录下的semisync_master.so、semisync_slave.so文件。安装插件模块。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;全同步：会一直等待返回ack。&lt;br&gt;&lt;br&gt;&lt;br&gt;总结：&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;1.为了提高集群的读能力，可以一主多从。或者一主从从从，从节点当做主节点，再弄几个从节点，减轻主节点的同步数据的压力。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;2.为了提高写的能力，可以多节点互主。（注意主键ID重复问题，要搞分布式ID）。&lt;br&gt;上面2种结合起来就是多主多从集群。&lt;br&gt;&lt;br&gt;&lt;br&gt;这种集群不具备高可用的功能，没有自动故障转移的功能（类似于redis的哨兵）：&lt;br&gt;MMM、MHA、MGR&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1500" y="1520" width="850" height="730" as="geometry" />
        </mxCell>
        <mxCell id="ICJE7UBgEt_on30tJHNk-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;分库分表：&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;为什么需要分库分表？单库的查询已经很慢了数据量大，索引都慢。&lt;br&gt;&lt;br&gt;分库、分表&amp;nbsp; 都可以从2个角度去拆分：水平拆分、垂直拆分。&lt;br&gt;&lt;br&gt;垂直拆分：这里大多数指的是垂直拆库。专库专用，不同业务的表分到不同的数据库里面。可以解决访问数据量大的问题，比如订单表的访问量很大，其它的表访问量很小，拆开之后不会影响到其它表。但是不能解决单表访问量大导致的性能下降。或者单表数据量大导致的查询效率慢。垂直拆分在设计数据库的时候就应该考虑到了。&lt;br&gt;&lt;br&gt;水平拆分：将表里面的数据，根据某些字段和规则，来分散到不同的表里或者库里。这样能解决单表数据量过大导致的查询效率问题。那针对热点数据访问量大的问题，只有分布在不同的数据库里并且在不同的机器里面，可以配合主从来解决吧？&lt;br&gt;&lt;br&gt;&lt;br&gt;常见的分片策略：&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;1.取模：能均匀分配数据到不同的节点。但是扩容非常麻烦。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;2.时间范围、其它范围：比较好扩容，但是数据分布不够均匀。容易发生数据倾斜问题。&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;如何设计一个不需要数据迁移的取模分片方案？&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;总结：业务上首选缓存、索引优化、读写分离。实在是业务量很大了，再考虑分库分表。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;动态数据源：DS&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;我们项目里面怎么做的？&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1500" y="2380" width="810" height="630" as="geometry" />
        </mxCell>
        <mxCell id="pqmF28eFS-mHkBI-EK1a-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;Sharding-Sphere&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="1460" y="3160" width="800" height="410" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
