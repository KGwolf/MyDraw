<mxfile host="app.diagrams.net" modified="2023-10-08T06:28:44.169Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36" etag="-YX3wVXih8MVctmsyQZj" version="22.0.4" type="github">
  <diagram name="第 1 页" id="L6XU-YJSm6NN8EeBNm4k">
    <mxGraphModel dx="1434" dy="1927" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="aYSDuqsWhtXODDXYn9be-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;为什么使用B+树作为存储数据结构呢？普通二叉树、B树、红黑树为什呢不行？&lt;br&gt;跳表跟B+树的区别是什么？&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;&lt;span style=&quot;&quot;&gt;Mysql为什么用B+树不用跳表？&lt;/span&gt;&lt;br&gt;&lt;br&gt;B+树结构和B树结构的区别？它们的叶子结点和非叶子结点存储的是什么？&lt;br&gt;&lt;br&gt;哈希索引的优劣势是什么？&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="50" y="60" width="750" height="170" as="geometry" />
        </mxCell>
        <mxCell id="aYSDuqsWhtXODDXYn9be-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;Mysql有2中存储引擎分别是什么？物理结构上如何区分？逻辑结构上有什么不同？&lt;br&gt;&lt;br&gt;Mysql中为什么要建议搞一个连续递增的主键呢？如果没有主键，数据库会先从列中找一个没有重复数据的列作为主键，如果没有满足的列，那么就会自己维护一个隐藏自增列作为主键？&lt;br&gt;&lt;br&gt;如果不是连续递增的，那么维护B+树的时候，插入就很麻烦了，就会频繁进行大量的调整，影响效率。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="44" y="240" width="836" height="170" as="geometry" />
        </mxCell>
        <mxCell id="aYSDuqsWhtXODDXYn9be-3" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;聚簇索引和非聚簇索引的区别？&lt;br&gt;&lt;br&gt;二级索引是什么意思？二级索引回表操作是什么意思？二级索引的叶子结点存的是什么？&lt;br&gt;&lt;br&gt;这里我们说的回表，指的是索引回表，除了索引回表，还有哪些操作可能会回表呢？&lt;br&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;回表也可以叫做 二次查找、二次检索。除了索引回表之外，还有连接回表，子查询回表。后面2个，是因为如果要获取连接表的列数据或者子查询表的结果时，就会进行回表。&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;font color=&quot;#0000ff&quot;&gt;回表为什么说是随机IO呢？随机IO和顺序IO的区别是什么？为什么顺序IO的效率要高很多呢？要避免回表？为什么随机IO的效率慢？慢在哪里了？&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;font color=&quot;#ff0000&quot;&gt;不仅仅回表是随机IO，而且普通的索引查询，如果走的是磁盘，也是随机IO。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;区别：随机IO，因为数据在磁盘上不是连续存储的，所以需要进行磁头寻道和磁盘旋转等操作。这些操作比较耗时，而顺序IO，因为是连续的存储在磁盘上，不需要这些耗时。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;注意：如果想要在新建一个文件里面实现顺序IO，那么必须要事先指定文件大小，好让文件提前占着磁盘的位置，这样才能顺序IO。&lt;br&gt;&lt;br&gt;Kafka之所以能够高效的进行磁盘读写，部分原因就是顺序IO：采用分段日志，每段日志固定大小，预先分配磁盘空间，采用消息追加的方式&lt;/font&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="44" y="420" width="756" height="480" as="geometry" />
        </mxCell>
        <mxCell id="DzlcBEAfJtIRjQRNxWo9-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;Explain的使用&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry y="1570" width="740" height="120" as="geometry" />
        </mxCell>
        <mxCell id="PFGi73NgZuRSLPyA7w7K-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;联合索引（包括联合主键索引）是什么？&lt;br&gt;&lt;br&gt;覆盖索引是什么？走二级索引一定比主键索引慢吗？走二级索引一定会进行回表吗？&lt;br&gt;&lt;br&gt;不一定的。如果查询的字段刚好二级索引（这里建立的是联合索引的二级索引）包含完了，那么就不会回表。而且因为二级索引跟主键索引比，不包含所有的字段数据。那可能查询起来就快一些。直接把B+树整体拿到内存里面查找。&lt;br&gt;&lt;br&gt;分析出来会走索引，数据库就一定会走索引吗？&lt;br&gt;其实不然，数据库自己还有优化，万一数据库觉得走全表扫描比走索引还快的话，就不会走索引了。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="10" y="1070" width="776" height="270" as="geometry" />
        </mxCell>
        <mxCell id="PFGi73NgZuRSLPyA7w7K-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;索引是什么？&lt;br&gt;&lt;br&gt;牢记索引是一种排好序的数据结构！且B+数的索引叶子结点包含了全部数据信息（二级索引除外）。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="40" y="-120" width="740" height="150" as="geometry" />
        </mxCell>
        <mxCell id="PFGi73NgZuRSLPyA7w7K-3" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;其实所有的优化原则的原理，根据下面这句宗旨去进行分析就很好理解：就记住B+树索引是排好序的数据结构，并且叶子节点包含了所有列的数据（二级索引存的是主键信息，会进行回表查询）。&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;比如：最左匹配，不能给索引列加函数方法，like的百分号要在右边。&lt;br&gt;&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;怎么分析呢？&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;最左匹配：因为索引是排好序的，比如 联合索引 name,age 。索引的排序是先按照name进行排序，如果name有相同的，再根据age进行排序。那如果你的where条件是age在前面，那怎么能找得到呢。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="10" y="1350" width="830" height="170" as="geometry" />
        </mxCell>
        <mxCell id="r750OqilGSKwBD_I3ron-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;索引下推是什么？&lt;br&gt;&lt;br&gt;mysql什么情况下回用到索引下推呢？&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="900" y="910" width="830" height="170" as="geometry" />
        </mxCell>
        <mxCell id="r750OqilGSKwBD_I3ron-3" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;一条sql是如何在mysql中执行的呢？&lt;br&gt;&lt;br&gt;mysql有哪些角色？&lt;br&gt;&lt;br&gt;词法分析器有哪些步骤？&lt;br&gt;&lt;br&gt;语法分析生成一个语法树，这个东西有什么意义，能使用在哪些方面呢？&lt;br&gt;分库分表：java有类库可以支持生成语法树，然后我们可以根据这个树，来判断走哪个库哪个表。&lt;br&gt;分布式事务回滚：&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="10" y="1760" width="840" height="240" as="geometry" />
        </mxCell>
        <mxCell id="MdRjEa7SP88yfNxcg5VE-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;索引如何优化呢？&lt;br&gt;&lt;br&gt;索引的建立是根据业务需求理解慢慢的来建立，慢慢的来优化的。不是凭脑袋空想！&lt;br&gt;&lt;br&gt;要充分利用联合索引，一张表可以建立2-3个联合索引，根据业务来决定。&lt;br&gt;&lt;br&gt;区间范围查找的字段要放在最后面。如果有多个区间范围查找，那么看看能不能优化，比如把age&amp;gt;20 and age &amp;lt;30 的这种范围sql优化成 age in (20,21...,30)。&lt;br&gt;&lt;br&gt;因为多个字段进行范围查找的话，可能只有第一个字段能走索引，后面的都不能走了。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1310" y="-90" width="810" height="240" as="geometry" />
        </mxCell>
        <mxCell id="MdRjEa7SP88yfNxcg5VE-2" value="下面的sql在39上面执行，要花费2分多钟。&lt;br&gt;去掉药品表的distinct之后，就只要70ms了。&lt;br&gt;&lt;br&gt;SELECT pat.mhiscode, pat.taskid, pat.caseid, pat.patientid, task.auditmodeid, mednum, recipetypecodeex, recipetypecode, recipetypename, reciperoutename, reciperoutecode, ordernum as index, frequency, singledose, num, numunit, druguniquecode, drugname, doseunit, duration, task.starttime, doctorcode, doctorname, deptcode, deptname, drug.prescno as presno, 1 as sourceType FROM pr.clinic_pat_info pat JOIN pr.clinic_task_info_history task ON pat.taskid = task.taskid AND pat.mhiscode = task.mhiscode JOIN(SELECT taskid, auditmodeid, max(sendtime) AS sendtime FROM pr.clinic_task_info_history WHERE taskid BETWEEN 202309160000000000 AND 202309230000000000 AND status &amp;gt;= 0 and status &amp;lt;&amp;gt; ANY(ARRAY[12, 24, 25, 26]) GROUP BY taskid, auditmodeid) history ON task.taskid = history.taskid AND task.auditmodeid = history.auditmodeid AND task.sendtime = history.sendtime JOIN (SELECT DISTINCT taskid, prescno, drugindex, ordernum, frequency, singledose, num, numunit, doseunit, duration FROM pr.clinic_pat_drug_order WHERE taskid BETWEEN 202309160000000000 AND 202309230000000000 AND ordertype &amp;lt;&amp;gt; ANY(ARRAY[1, 2])) drug ON history.taskid = drug.taskid LEFT JOIN (select * from pr.clinic_pat_recipe where taskid between 202309160000000000 AND 202309230000000000) recipe ON drug.taskid = recipe.taskid AND drug.prescno = recipe.prescno LEFT JOIN pr.drug_index index ON drug.drugindex = index.drugindex WHERE pat.taskid BETWEEN 202309160000000000 AND 202309230000000000 AND task.taskid BETWEEN 202309160000000000 AND &lt;br&gt;202309230000000000 AND task.status &amp;gt;= 0 and task.status &amp;lt;&amp;gt; ANY(ARRAY[12, 24, 25, 26]) ORDER BY task.taskid, task.sendtime" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1320" y="250" width="910" height="220" as="geometry" />
        </mxCell>
        <mxCell id="X4JwkC8u1-y5Jrn2BpA5-1" value="select * from tableA where id in (select id from tableA where name =xxx and 。。。)&lt;br&gt;select * froom tableA as a inner join (select id fromtableA where name =xxx and 。。。) as b on&amp;nbsp; a.id = b.id&lt;br&gt;这种 in 和join的效率相比咋样（可能子查询的条数多了之后，就不会走主键索引了？可能mysql认为全表扫描比索引还快点？）？2个sql都是用到了二级索引，缩小了记录条数，然后再查找所有的字段。" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1440" y="560" width="640" height="90" as="geometry" />
        </mxCell>
        <mxCell id="X4JwkC8u1-y5Jrn2BpA5-2" value="inner join on 条件的指定，走索引和不走索引的区别是什么？&lt;br&gt;&lt;br&gt;各种join的原理是什么？&lt;br&gt;&lt;br&gt;小表 inner join 大表&amp;nbsp; &amp;nbsp;pk&amp;nbsp; &amp;nbsp; 大表&amp;nbsp; inner join 小表&amp;nbsp; &amp;nbsp;的区别？&lt;br&gt;&lt;br&gt;join on 有没有走索引的区别？&lt;br&gt;&lt;br&gt;count(*)、count(1)、count(二级索引)、count(主键)、count(没有索引) 之前的效率区别?&lt;br&gt;&lt;br&gt;阿里巴巴的mysql规范。" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1390" y="710" width="650" height="190" as="geometry" />
        </mxCell>
        <mxCell id="1pvLfjOu5_eiv0kYw-xj-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;MVCC机制原理：&lt;br&gt;跟事务隔离级别的关系？&lt;br&gt;&lt;br&gt;Buffer Pool跟redo log、undolog、binlog之间的关系，以及一条sql如何执行的关系。流程图，先undo--&amp;gt;redo---&amp;gt;binlog。&lt;br&gt;&lt;br&gt;redolog是用来恢复Buffer Pool里面的数据的。&lt;br&gt;binlog是用来恢复磁盘里面的数据的。&lt;br&gt;&lt;br&gt;为什么要有Buffer Pool？&lt;br&gt;其实很多中间件都有这个玩意儿，目的就是为了防止频繁的进行文件IO操作，影响效率。内存的操作速度是文件IO的多少次方倍。&lt;br&gt;&lt;br&gt;既然IO操作费时间，那么为什么事务的流程里面还要写这么多的日志呢？这个难道不费时间吗？&lt;br&gt;这里就是顺序IO和随机IO的区别了。这个差距是很大的，我们写日志是顺序IO，但是直接写数据的话，就是随机读写了。这跟Kafka有点像。&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="20" y="2060" width="1020" height="360" as="geometry" />
        </mxCell>
        <mxCell id="DgoiZzh3QHl1QlPg7UnV-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;InnoDB的3大特性（与事务无关）&lt;br&gt;&lt;br&gt;MyIsam为什么都是稀疏索引？&lt;br&gt;&lt;br&gt;B+树为什么说3层效率最高？如果一行记录是1kb，那么3层B+树最多可以存储2500W行记录？这个是怎么计算的？&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="850" y="670" width="520" height="150" as="geometry" />
        </mxCell>
        <mxCell id="DgoiZzh3QHl1QlPg7UnV-3" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;三星索引是什么？&lt;br&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" vertex="1" parent="1">
          <mxGeometry x="890" y="1920" width="450" height="130" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
