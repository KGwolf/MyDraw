<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36" version="27.1.4">
  <diagram name="第 1 页" id="4cmuizqChZSZ_57hS7zJ">
    <mxGraphModel dx="4506" dy="2671" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="rPxvf-ZjiWcw2DGCV5X8-1" value="1.系统设置的规则可以单独设计一个子领域？还是单独设计一个充血模型实体？&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.json串里面的每一个节点，比如病人、诊断等，都可以设计一个子领域？还是一个充血模型实体？&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontStyle=1;fontSize=18;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="30" y="280" width="760" height="220" as="geometry" />
        </mxCell>
        <mxCell id="rPxvf-ZjiWcw2DGCV5X8-2" value="刚开始的系统需求很少：&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;系统审核--&amp;gt;提交人工审核---&amp;gt;通过。&lt;br&gt;&lt;/div&gt;&lt;div&gt;经过需求迭代：系统审核（可能根据规则有不同的逻辑了：重复过滤、自动干预等。还有药师监测标准、自动监测标准的影响设置任务状态）。提交人工审核（药师中途离场怎么办，转交？直接通过？双签等逻辑）。都会极大的让代码复杂化，维护成本高。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;刚开始的系统--&amp;gt;业务需求更改越来越多的时候：需要进行利用设计模式进行代码重构，比如策略模式、责任链模式来改造代码，那么应该用什么样的思想来进行指导这种重构呢？特别是经历N多次的需求迭代。DDD就适合做这种复杂业务的重构，利用领域建模来实现真实世界的需求变化，从而指导我们的进一步编码。先对业务熟悉形成领域模型，然后利用领域模型去指导开发。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;聚合关系是怎样的情况，什么样的关系可以用聚合？订单和订单明细是一种聚合关系，当需要修改订单明细，比如增加一个订单的时候，那么就需要把整个订单重新提交。前端、service需要把整个订单明细和订单一起提交，然后交给底层去实现新插入一条。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;软件的本质就是对真实世界的模拟&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如何进行ddd设计：&lt;span style=&quot;background-color: transparent; color: light-dark(rgb(0, 0, 0), rgb(255, 255, 255));&quot;&gt;需求分析---&amp;gt;领域建模---&amp;gt;设计编码&lt;/span&gt;&lt;/div&gt;&lt;div&gt;1.领域建模的过程（最终UML类图）：对业务的抽象，形成uml类图，完全跟具体的技术无关。当需求变化的时候，在类图上面去进行业务分析然后变更类图。&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;比如订单：订单领域实体类，包括了：订单id，数量，用户信息、地址信息、订单详情信息等等。后面3个的关系是多个订单对应1个用户，多个订单对应1个地址信息，订单和订单详情是1对多，并且是聚合关系。用户和地址也是一种聚合关系。&amp;nbsp; 那么如果简简单单的一个类里面，是体现不出来这些信息的，需要写一个xml文件来说明这些信息（如果有低代码平台的话就需要），这样，后面代码实现的时候，发现有聚合的关系，那么保存的时候，这2个东西都要一起保存的（交由仓储层来实现的）。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;整个的service方法，不关注底层什么数据库，消息中间件，缓存等等。，只关心自己的业务。缓存封装在仓储里面，mq封装在领域事件通知里面。领域事件通知通过mq来实现。技术和业务实现了隔离。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.领域模型指导数据库设计：&lt;/div&gt;&lt;div&gt;3.领域模型指导软件设计：&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontStyle=1;fontSize=18;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-110" y="-530" width="890" height="760" as="geometry" />
        </mxCell>
        <mxCell id="UmYx8IvlajbbxUEQeoFi-1" value="ddd的设计过程：需求分析---&amp;gt;领域建模---&amp;gt;设计编码&lt;div&gt;1.业务分析：统一语言和事件风暴&lt;/div&gt;&lt;div&gt;2.领域设计：服务、实体、值对象&lt;/div&gt;&lt;div&gt;3.微服务拆分：聚合、限界上下文与领域事件&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;领域建模的过程：事件风暴。&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontStyle=1;fontSize=18;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-960" y="100" width="760" height="220" as="geometry" />
        </mxCell>
        <mxCell id="UmYx8IvlajbbxUEQeoFi-2" value="防腐层：&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;比如订单支付，有N多种支付方式，这时候，我们是做一个支付方式的接口，然后实现各种支付方式类。这样就还有一些问题，实现类里面可能还有其他业务逻辑，跟第三方sdk交互的逻辑也混合在一起了，修改起来就不是很方便了，找起来费劲，而且这样就不好mock测试。所以就可以使用适配器模式来进行改造，将与sdk交互的逻辑抽离出来放进适配器方法里面，这样以后sdk有变动就只用修改适配器的方法，mock测试的时候，支付服务也可以进行mock。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;上面举的例子是领域层调用基础设施层，除此之外，领域层调用领域层也需要使用防腐层来实现（本地Fegin接口实现）。&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;fontStyle=1;fontSize=18;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-970" y="-320" width="760" height="220" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
