<mxfile host="app.diagrams.net" modified="2023-09-03T05:53:01.320Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69" etag="H2PHA6g3dvVmdsUjuHX-" version="21.7.2" type="github">
  <diagram name="第 1 页" id="oAc0U7i2WO9zVuW95_pL">
    <mxGraphModel dx="3040" dy="1928" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-1" value="&lt;b style=&quot;border-color: var(--border-color); font-size: 18px;&quot;&gt;volatile为什么只能保证可见性和有序性，不能保证原子性？&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;volatile实现可见性和有序性的原理是加了内存屏障。&lt;br&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;b style=&quot;background-color: initial; border-color: var(--border-color);&quot;&gt;&lt;font color=&quot;#ff3333&quot;&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;volatile&lt;/b&gt;在JVM中来说是加了一个StoreLoad屏障。那么对应着硬件的实现在不同的架构上面有不同的实现。x86中，JVM的StoreLoad屏障对应着mfence指令，最终调用的是lock前缀指令，这个lock指令是能锁对应的缓存行。&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;/b&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="90" y="650" width="690" height="170" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-2" value="&lt;font style=&quot;&quot;&gt;&lt;b style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 48px;&quot;&gt;并发编程的三大特性：可见性、有序性、原子性。&lt;br&gt;&lt;/font&gt;&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=center;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-350" y="-10" width="2810" height="120" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-3" value="&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;那什么是可见性呢？&lt;/b&gt;&lt;/div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;这就要从JMM模型说起了，那JMM是什么呢？&lt;/b&gt;&lt;/div&gt;&lt;b&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;JMM：java memory model，java内存模型。&lt;font color=&quot;#ff3333&quot;&gt;它屏蔽了各种操作系统的内存访问差异，规范了多线程程序访问内存的方式（规定了一个线程如何何时可以看到由其它线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。）&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-390" y="170" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-4" value="&lt;b style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;在多核CPU中，JMM规定了怎么访问共享内存，首先在主存里面存在一个共享数据且线程A和线程B由不同的CPU内核执行。那JVM中规定了每个线程都有自己的线程栈，相当于是&lt;font style=&quot;&quot; color=&quot;#ff3333&quot;&gt;每个线程都有自己的独有内存，都程会单独拷贝主存（这里的主存可能来自硬件的不同地方，比如一二三级缓存、寄存器、主内存、IO设备）里面的数据&lt;/font&gt;。那么&lt;font style=&quot;&quot; color=&quot;#ff3333&quot;&gt;这种模型，可能就会导致一个线程修改了共享变量的值之后，对另外一个线程不可见。&lt;/font&gt;这就是可见性。&lt;/font&gt;&lt;/b&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="360" y="170" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-5" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;那其实JMM跟硬件CPU读取内存变量其实是有差异的。&lt;br&gt;硬件可能也会有缓存一致性的问题。那么硬件的工作模型是：主存存放所有的计算数据。多核CPU的情况，每个CPU核心都会有自己的一二级缓存，有的计算机也会有共享的三级缓存。那么CPU会将主存中的数据，读取到自己的一二级缓存中去。这样也可能会有修改了数据，其它核心不可见。&lt;br&gt;&lt;font color=&quot;#ff3333&quot;&gt;JVM中的数据（线程栈和堆）可能会来自计算机硬件上的一二三级缓存、寄存器、主内存、IO设备。&lt;/font&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="1070" y="150" width="660" height="190" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-6" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;font style=&quot;&quot;&gt;&lt;b style=&quot;&quot;&gt;&lt;font color=&quot;#0000ff&quot;&gt;那么硬件上怎么处理这种缓存不一致的问题呢？有各种针对不同CPU架构的协议，比如MESI协议，MESI的原理是什么呢？&lt;/font&gt;&lt;br&gt;&lt;font style=&quot;&quot; color=&quot;#ff3333&quot;&gt;这些协议通过在缓存中标记缓存的状态来协调不同核心之间的缓存操作。MESI协议是一个基于写失效的协议，支持回写缓存。&lt;/font&gt;&lt;/b&gt;&lt;/font&gt;&lt;b style=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;从硬件的模型上来说，保证2个CPU核心处理同一个内存变量的缓存一直问题，有2种方式：&lt;br&gt;1.锁总线，一次只能有1个CPU核心来处理数据，这样就不会有问题，但是效率极低。&lt;br&gt;2.锁缓存行，只锁定内存中很小的区域缓存行，不会影响其他核心操作其他内存空间数据，效率比锁总线高&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#0000ff&quot;&gt;那么硬件是怎么知道缓存行需要被锁定的呢？&lt;/font&gt;&lt;br&gt;硬件上有一个协议机制，&lt;font color=&quot;#ff3333&quot;&gt;总线窥探机制（窥探每个缓存行发生变化的状态）&lt;/font&gt;，每个核心都会有一个窥探者，会观察总线上是否存在修改缓存的事务，出现了就查看自己是否有对应的副本。会执行一个动作来保证一致性（刷新缓存块或者让缓存块失效，这里应该是每个核心自己的缓存块）。&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#0000ff&quot;&gt;基于写失效的缓存一致性协议（MESI）的原理？&lt;br&gt;&lt;/font&gt;&lt;/b&gt;&lt;b&gt;当第一个核心读取缓存行内容时，标记为Exclusive，如果还有另外的核心在读取同一个缓存行，则缓存行标记为Shared，如果有修改缓存数据，写回到主存时，缓存行则变为Modify，若发现其它内核还有副本，则让缓存行的其它副本变为Invalid。&lt;br&gt;&lt;/b&gt;&lt;b style=&quot;&quot;&gt;&lt;font color=&quot;#ff3333&quot;&gt;注意：被标记的都是各个核心中的缓存行，通过总线窥探机制来知晓其它核心中的同一个缓存行状态，比如一发现有一个核心的缓存行成为了Modify状态，那么其余的这些核心副本都会变成Invalid。&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/b&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;&lt;font color=&quot;#0000ff&quot;&gt;那么硬件的缓存一致性协议跟JMM规定的内存访问方式的区别是什么呢？&lt;/font&gt;&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;&lt;/b&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;JMM只是一种规范，并不是实际的实现。实际的实现还是通过硬件的指令来的，比如volatile在JMM中是加内存屏障，但是在硬件上面是lock指令来锁定缓存行。&lt;/b&gt;&lt;/font&gt;&lt;b style=&quot;&quot;&gt;&lt;br&gt;&lt;/b&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="1840" y="140" width="1120" height="560" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-7" value="&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;什么是有序性？有序性会导致什么问题？怎么解决有序性的问题呢？&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-1170" y="950" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-10" value="&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;什么是可见性？可见性会导致什么问题？怎么解决可见性的问题呢？&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-1160" y="175" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-11" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;JVM中的内存屏障和操作系统的内存屏障的区别？&lt;br&gt;&lt;font color=&quot;#ff3333&quot;&gt;JMM屏蔽了各种底层硬件的差异，由JVM来为不同的平台生成相应的机器码。&lt;/font&gt;&lt;br&gt;JAVA中有这几种内存屏障：&lt;br&gt;1.LoadLoad屏障&lt;br&gt;2.LoadStore屏障&lt;br&gt;3.StoreStore屏障&lt;br&gt;4.&lt;font color=&quot;#ff3333&quot;&gt;StoreLoad屏障：x86架构中只有这个有实现，是一个万能屏障，对应着mfence和lock前缀指令&lt;/font&gt;&lt;br&gt;硬件中的内存屏障：&lt;br&gt;1.Ifence&lt;br&gt;2.sfence&lt;br&gt;3.mfence：全能指令&lt;br&gt;4.lock指令：不是屏障，但是能完成屏障的功能。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="840" y="640" width="790" height="280" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-13" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;哪些方法可以保证可见性？&lt;br&gt;1.volatile&lt;br&gt;2.内存屏障&lt;br&gt;3.synchronized&lt;br&gt;4.lock指令&lt;br&gt;5.final&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-360" y="350" width="460" height="160" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-14" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;哪些方法可以保证有序性？&lt;br&gt;1.volatile&lt;br&gt;2.内存屏障&lt;br&gt;3.synchronized&lt;br&gt;4.lock&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-290" y="1030" width="450" height="130" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-15" value="&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;什么是原子性？原子性会导致什么问题？怎么解决原子性的问题呢？&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-1180" y="1910" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-16" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;哪些方法可以保证原子性？&lt;br&gt;1.synchronized&lt;br&gt;2.lock&lt;br&gt;3.cas&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-230" y="1905" width="460" height="160" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-17" value="&lt;div style=&quot;text-align: center;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;什么是有序性：CPU执行指令的顺序就是我们写的代码的顺序。这就是顺序性&lt;/b&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-300" y="920" width="430" height="60" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-18" value="&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;有序性的问题：比如著名的双重检查锁。&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=middle;align=center;" parent="1" vertex="1">
          <mxGeometry x="199" y="920" width="421" height="60" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-19" value="&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;什么是happen-before原则？有一个原则是关于volatile的。&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1790" y="890" width="430" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-20" value="&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;&lt;font color=&quot;#0000ff&quot;&gt;硬件层面的缓存行是什么。缓存行对齐是什么？有什么好处？&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;缓存行指的是处理器缓存数据的最小单位。通常是64个字节。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;为什么会有缓存行对齐，是因为一个缓存行里面可能存在多个共享的数据，如果其中的一个数据是多线程并发，那么根据缓存一致性协议，会进行lock指令锁住整个缓存行，会导致行里面其它的数据也被锁住，导致效率出现问题。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;这样就出现了缓存行对齐。就是1个数据对应着64个字节。不足64个字节的用其它来填充满。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="3010" y="210" width="620" height="160" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
