<mxfile host="app.diagrams.net" modified="2023-09-23T14:28:40.561Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.36" etag="itws7LUcgO8LoAFGkmKK" version="21.7.2" type="github">
  <diagram name="第 1 页" id="oAc0U7i2WO9zVuW95_pL">
    <mxGraphModel dx="3285" dy="3231" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="dvuJLhcE7HCTMrbFaXMl-6" value="" style="rounded=0;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;" parent="1" vertex="1">
          <mxGeometry x="-580" y="1560" width="1330" height="370" as="geometry" />
        </mxCell>
        <mxCell id="dvuJLhcE7HCTMrbFaXMl-1" value="&lt;font style=&quot;font-size: 48px;&quot;&gt;可见性问题&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;labelBackgroundColor=#FFFFFF;labelBorderColor=#FFFFFF;fillColor=#dae8fc;strokeColor=#6c8ebf;" parent="1" vertex="1">
          <mxGeometry x="-580" y="-170" width="2620" height="1450" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-1" value="&lt;b style=&quot;border-color: var(--border-color); font-size: 18px;&quot;&gt;volatile为什么只能保证可见性和有序性，不能保证原子性？&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;volatile实现可见性和有序性的原理是加了内存屏障。&lt;br&gt;&lt;div style=&quot;text-align: left;&quot;&gt;&lt;b style=&quot;background-color: initial; border-color: var(--border-color);&quot;&gt;&lt;font color=&quot;#ff3333&quot;&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;volatile&lt;/b&gt;在JVM中来说是加了一个StoreLoad屏障。那么对应着硬件的实现在不同的架构上面有不同的实现。x86中，JVM的StoreLoad屏障对应着mfence指令，最终调用的是lock前缀指令，这个lock指令是能锁对应的缓存行。&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;/b&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="10" y="950" width="690" height="170" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-2" value="&lt;font style=&quot;&quot;&gt;&lt;b style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 48px;&quot;&gt;并发编程的三大特性：可见性、有序性、原子性。&lt;br&gt;&lt;/font&gt;&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=center;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-1340" y="-610" width="3600" height="120" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-3" value="&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;那什么是可见性呢？&lt;/b&gt;&lt;/div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;这就要从JMM模型说起了，那JMM是什么呢？&lt;/b&gt;&lt;/div&gt;&lt;b&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;JMM：java memory model，java内存模型，&lt;font color=&quot;#ff0000&quot;&gt;它是一种规范&lt;/font&gt;。&lt;font color=&quot;#ff3333&quot;&gt;它屏蔽了各种操作系统的内存访问差异，规范了多线程程序访问内存的方式（规定了一个线程如何何时可以看到由其它线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。），定义了一写原则happens-before原则。&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#ff3333&quot;&gt;JMM和这个规则是抽象出来的一种规范，屏蔽了底层系统的差异。确保了多线程程序的正确性，让程序员更容易在多线程环境下写出正确的程序。&lt;/font&gt;&lt;/div&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-510" y="-160" width="690" height="220" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-4" value="&lt;b style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;在多核CPU中，JMM规定了怎么访问共享内存，首先在主存里面存在一个共享数据且线程A和线程B由不同的CPU内核执行。那JVM中规定了每个线程都有自己的线程栈，相当于是&lt;font style=&quot;&quot; color=&quot;#ff3333&quot;&gt;每个线程都有自己的独有内存，都程会单独拷贝主存（这里的主存可能来自硬件的不同地方，比如一二三级缓存、寄存器、主内存、IO设备）里面的数据&lt;/font&gt;。那么&lt;font style=&quot;&quot; color=&quot;#ff3333&quot;&gt;这种模型，可能就会导致一个线程修改了共享变量的值之后，对另外一个线程不可见。&lt;/font&gt;这就是可见性。&lt;/font&gt;&lt;/b&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="350" y="10" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-5" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;那其实JMM跟硬件CPU读取内存变量其实是有差异的。&lt;br&gt;硬件可能也会有缓存一致性的问题。那么硬件的工作模型是：主存存放所有的计算数据。多核CPU的情况，每个CPU核心都会有自己的一二级缓存，有的计算机也会有共享的三级缓存。那么CPU会将主存中的数据，读取到自己的一二级缓存中去。这样也可能会有修改了数据，其它核心不可见。&lt;br&gt;&lt;font color=&quot;#ff3333&quot;&gt;JVM中的数据（线程栈和堆）可能会来自计算机硬件上的一二三级缓存、寄存器、主内存、IO设备。&lt;/font&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="1210" width="660" height="190" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-6" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;font style=&quot;&quot;&gt;&lt;b style=&quot;&quot;&gt;&lt;font color=&quot;#0000ff&quot;&gt;那么硬件上怎么处理这种缓存不一致的问题呢？有各种针对不同CPU架构的协议，比如MESI协议，MESI的原理是什么呢？&lt;/font&gt;&lt;br&gt;&lt;font style=&quot;&quot; color=&quot;#ff3333&quot;&gt;这些协议通过在缓存中标记缓存的状态来协调不同核心之间的缓存操作。MESI协议是一个基于写失效的协议，支持回写缓存。&lt;/font&gt;&lt;/b&gt;&lt;/font&gt;&lt;b style=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;从硬件的模型上来说，保证2个CPU核心处理同一个内存变量的缓存一直问题，有2种方式：&lt;br&gt;1.锁总线，一次只能有1个CPU核心来处理数据，这样就不会有问题，但是效率极低。&lt;br&gt;2.锁缓存行，只锁定内存中很小的区域缓存行，不会影响其他核心操作其他内存空间数据，效率比锁总线高&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#0000ff&quot;&gt;那么硬件是怎么知道缓存行需要被锁定的呢？&lt;/font&gt;&lt;br&gt;硬件上有一个协议机制，&lt;font color=&quot;#ff3333&quot;&gt;总线窥探机制（窥探每个缓存行发生变化的状态）&lt;/font&gt;，每个核心都会有一个窥探者，会观察总线上是否存在修改缓存的事务，出现了就查看自己是否有对应的副本。会执行一个动作来保证一致性（刷新缓存块或者让缓存块失效，这里应该是每个核心自己的缓存块）。&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#0000ff&quot;&gt;基于写失效的缓存一致性协议（MESI）的原理？&lt;/font&gt;&lt;br&gt;其中有4个对应的缓存行状态：Modify、Exclusive、Shared、Invalid。&lt;br&gt;&lt;/b&gt;&lt;b&gt;当第一个核心读取缓存行内容时，标记为Exclusive，如果还有另外的核心在读取同一个缓存行，则缓存行标记为Shared，如果有修改缓存数据，写回到主存时，缓存行则变为Modify，若发现其它内核还有副本，则让缓存行的其它副本变为Invalid。&lt;br&gt;&lt;/b&gt;&lt;b style=&quot;&quot;&gt;&lt;font color=&quot;#ff3333&quot;&gt;注意：被标记的都是各个核心中的缓存行，通过总线窥探机制来知晓其它核心中的同一个缓存行状态，比如一发现有一个核心的缓存行成为了Modify状态，那么其余的这些核心副本都会变成Invalid。&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/b&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;&lt;font color=&quot;#0000ff&quot;&gt;那么硬件的缓存一致性协议跟JMM规定的内存访问方式的区别是什么呢？&lt;/font&gt;&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;&lt;/b&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;JMM只是一种规范，并不是实际的实现。实际的实现还是通过硬件的指令来的，比如volatile在JMM中是加内存屏障，但是在硬件上面是lock指令来锁定缓存行。&lt;/b&gt;&lt;/font&gt;&lt;b style=&quot;&quot;&gt;&lt;br&gt;&lt;/b&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-490" y="320" width="1170" height="570" as="geometry" />
        </mxCell>
        <mxCell id="dvuJLhcE7HCTMrbFaXMl-7" style="edgeStyle=orthogonalEdgeStyle;shape=flexArrow;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="rkv5G4KE9S5kMJV3ECuV-7" target="dvuJLhcE7HCTMrbFaXMl-6" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-7" value="&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;什么是有序性？有序性会导致什么问题？怎么解决有序性的问题呢？&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-1510" y="1670" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="dvuJLhcE7HCTMrbFaXMl-3" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;shape=flexArrow;" parent="1" source="rkv5G4KE9S5kMJV3ECuV-10" target="dvuJLhcE7HCTMrbFaXMl-1" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-10" value="&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;什么是可见性？可见性会导致什么问题？怎么解决可见性的问题呢？&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-1497" y="480" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-11" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;JVM中的内存屏障和操作系统的内存屏障的区别？&lt;br&gt;&lt;font color=&quot;#ff3333&quot;&gt;JMM屏蔽了各种底层硬件的差异，由JVM来为不同的平台生成相应的机器码。&lt;/font&gt;&lt;br&gt;JAVA中有这几种内存屏障：&lt;br&gt;1.LoadLoad屏障&lt;br&gt;2.LoadStore屏障&lt;br&gt;3.StoreStore屏障&lt;br&gt;4.&lt;font color=&quot;#ff3333&quot;&gt;StoreLoad屏障：x86架构中只有这个有实现，是一个万能屏障，对应着mfence和lock前缀指令&lt;/font&gt;&lt;br&gt;硬件中的内存屏障：&lt;br&gt;1.Ifence&lt;br&gt;2.sfence&lt;br&gt;3.mfence：全能指令&lt;br&gt;4.lock指令：不是屏障，但是能完成屏障的功能。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="827" y="950" width="790" height="280" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-13" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;哪些方法可以保证可见性？&lt;br&gt;1.volatile&lt;br&gt;2.内存屏障&lt;br&gt;3.synchronized&lt;br&gt;4.lock指令&lt;br&gt;5.final&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-510" y="950" width="460" height="160" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-14" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;哪些方法可以保证有序性？&lt;br&gt;1.volatile&lt;br&gt;2.内存屏障&lt;br&gt;3.synchronized&lt;br&gt;4.lock指令&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-540" y="1680" width="450" height="130" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-15" value="&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;什么是原子性？原子性会导致什么问题？怎么解决原子性的问题呢？&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" parent="1" vertex="1">
          <mxGeometry x="-1500" y="2270" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-16" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;哪些方法可以保证原子性？&lt;br&gt;1.synchronized&lt;br&gt;2.lock指令&lt;br&gt;3.cas&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-620" y="2270" width="440" height="140" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-17" value="&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;什么是有序性：CPU执行指令的顺序就是我们写的代码的顺序。这就是顺序性&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;但是最终其实是CPU来执行我们代码经过编译成的二进制文件。那么CPU自己也有优化：&lt;font color=&quot;#ff3333&quot;&gt;指令重排序&lt;/font&gt;，来提高执行指令的性能。&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;比如著名的&lt;font color=&quot;#ff3333&quot;&gt;双重检查锁&lt;/font&gt;：new 一个对象的指令有3条：&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;1.分配内存空间，堆上申请一块内存。&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;2.初始化对象，执行构造方法。&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;3.返回对象引用，赋值引用。&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;CPU可能对2、3步骤的顺序进行颠倒。这样多线程情况下就会出现问题，返回空对象。&lt;/b&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-40" y="1614" width="680" height="280" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-19" value="&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;&lt;font color=&quot;#0000ff&quot;&gt;什么是happen-before原则？&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;&lt;font color=&quot;#ff3333&quot;&gt;是JMM中定义的一组规则，用于定义多线程程序中操作之间的执行顺序和可见性关系。&lt;/font&gt;&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;1.程序顺序规则：同一个线程中，执行按顺序发生。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;2.监视器锁规则：多线程同步，使用锁（synchronized）时，释放锁发生在获取同一个锁之前。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;3.volatile变量规则：对volatile修饰的变量，写操作发生在读操作之前。保证可见性。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;4.线程启动规则：启动一个线程的操作发生在线程中的任何操作之前。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;5.线程终止规则：线程的所有操作发生在线程终止之前。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;6.传递性规则：A操作发生在B操作之前，B操作发生在C操作之前，那么A在C之前发生。（比如一个线程对共享变量进行写操作，然后释放锁，另外线程获取了锁进行读。那么这个读一定能读到之前写的数据）&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="827" y="650" width="880" height="220" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-20" value="&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;&lt;font color=&quot;#0000ff&quot;&gt;硬件层面的缓存行是什么。缓存行对齐是什么？有什么好处？&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;缓存行指的是处理器缓存数据的最小单位。通常是64个字节。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;为什么会有缓存行对齐，是因为一个缓存行里面可能存在多个共享的数据，如果其中的一个数据是多线程并发，那么根据缓存一致性协议，会进行lock指令锁住整个缓存行，&lt;font color=&quot;#ff3333&quot;&gt;会导致行里面其它的数据也被锁住，出现伪共享问题&lt;/font&gt;，导致效率出现问题。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;这样就出现了缓存行对齐。就是1个数据对应着64个字节。不足64个字节的用其它来填充满。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="830" y="300" width="640" height="270" as="geometry" />
        </mxCell>
        <mxCell id="dvuJLhcE7HCTMrbFaXMl-8" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;什么是进程、线程、协程、什么是并发、什么是并行？&lt;br&gt;&lt;br&gt;&lt;br&gt;线程间通信的方式有哪些？进程间通信的方式有哪些？&lt;br&gt;&lt;br&gt;&lt;br&gt;线程作为操作系统执行调度资源的最小单位。且每个CPU核心不是一直执行在一个进程（线程）上面，它会有时间片的概念，在某一段时间之内（比如10ms）会进行上下文切换，保存现场环境（主要是将寄存器等的值保存到主存里面），去执行另外的进程。&lt;br&gt;&lt;br&gt;这个上下文切换是会从用户态切换到内核态，这样会耗费很多时间。所以我们要尽量避免这种切换（选择哪种锁来同步的时候）。&lt;br&gt;&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-630" y="-1630" width="1200" height="330" as="geometry" />
        </mxCell>
        <mxCell id="dvuJLhcE7HCTMrbFaXMl-9" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;线程池的使用方式，原理是什么，那7个参数代表什么意思？&lt;br&gt;&lt;br&gt;线程池的核心数应该怎么设置?&lt;br&gt;&lt;br&gt;不同的业务最好使用不同的线程池。如果都共用一个线程池，那么极可能某个业务模块阻塞，引起全局阻塞。&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-650" y="-1190" width="900" height="210" as="geometry" />
        </mxCell>
        <mxCell id="dvuJLhcE7HCTMrbFaXMl-10" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;ThreadLocal的原理是什么，有什么作用？&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="470" y="-1230" width="900" height="210" as="geometry" />
        </mxCell>
        <mxCell id="H64BaJxj17bUCx6KOZhM-1" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;线程有哪些方法，如何优雅的停止一个线程？&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;start()：启动一个新的线程去执行，最终会调用run方法。&lt;/b&gt;&lt;br&gt;&lt;b&gt;run() ：不会启动一个新的线程去执行。&lt;/b&gt;&lt;br&gt;&lt;b&gt;sleep()：线程等待多少秒。会&lt;font color=&quot;#ff0000&quot;&gt;让出时间片，不会释放对象锁。&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;yeild()：从running转成runnable状态。&lt;font color=&quot;#ff0000&quot;&gt;让出时间片，不会释放对象锁&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;join()：等待调用Join方法的线程执行完再继续执行。&lt;font color=&quot;#ff0000&quot;&gt;不会释放时间片，会阻塞线程，调用的wait()。&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;stop()：暴力停止线程，已经被弃用。可能会造成数据不一致的情况（会释放锁）。&lt;/b&gt;&lt;br&gt;&lt;b&gt;interrupt()：将线程的中断标志位设置成true，不会停止线程。&lt;/b&gt;&lt;br&gt;&lt;b&gt;isInterrupted()：判断当前线程的中断标志位是不是true，&lt;font color=&quot;#ff0000&quot;&gt;不会清除中断标志位。&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;Thread.interrupted()：判断当前线程的中断标志位是不是true，并&lt;font color=&quot;#ff0000&quot;&gt;清除标志，重新设置成false。&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;java里面通过中断机制来优雅的停止一个线程！中断机制是一个协作机制，不能直接中断一个线程，而是需要线程自己收到中断信号后自己处理，比如for循环条件是中断信号为true &amp;amp;&amp;amp; 自定义条件，跳出循环，线程结束。&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="640" y="-1700" width="1060" height="400" as="geometry" />
        </mxCell>
        <mxCell id="H64BaJxj17bUCx6KOZhM-2" value="&lt;b style=&quot;border-color: var(--border-color); font-size: 18px;&quot;&gt;synchronized的原理，底层实现，锁升级的过程&lt;br&gt;&lt;/b&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;b style=&quot;border-color: var(--border-color); font-size: 18px;&quot;&gt;&lt;br&gt;&lt;font color=&quot;#0000ff&quot;&gt;synchronized、AQS、管程、MESA之间的关系？&lt;/font&gt;&lt;br&gt;sync是jvm对管程的一种实现，AQS是java层面对管程模型的实现&lt;br&gt;&lt;br&gt;&lt;br&gt;锁的种类体系有哪些？&lt;br&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;&lt;br&gt;什么是可重入的锁？为什么要实现可重入呢？&lt;br&gt;&lt;br&gt;一个对象占多少字节（一个Object、一个自定义类的对象）&lt;br&gt;&lt;br&gt;为什么Object里面有wait和notify呢？且这2个方法不是在Thread类里面？&lt;br&gt;&lt;br&gt;对象头有哪些内容，跟锁有什么关系？&lt;br&gt;&lt;br&gt;synchronized在jdk1.5后做了哪些优化措施?&lt;br&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="70" y="2870" width="710" height="430" as="geometry" />
        </mxCell>
        <mxCell id="H64BaJxj17bUCx6KOZhM-3" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;AQS的数据结构，&lt;br&gt;找一个实现类比如ReEntryLock，是如何时间加锁解锁的，&lt;br&gt;AQS实现的独占锁、共享锁的区别，&lt;br&gt;自己实现一个AQS锁，只需要重写哪些方法就行？一些公共的比如加锁解锁、入队出队操作AQS都已经做好了，这些是基础的逻辑？&lt;br&gt;如何实现可重入的，如何并发的创建一个链表。如何并发的入队。比如实现一个AQS，哪些操作会存在线程安全呢？&lt;br&gt;&lt;br&gt;AQS和CAS之间的关系&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1001" y="2270" width="619" height="250" as="geometry" />
        </mxCell>
        <mxCell id="H64BaJxj17bUCx6KOZhM-4" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;reentrylock有2个for循环，1个保证入队，1个保证加锁&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1030" y="2590" width="590" height="140" as="geometry" />
        </mxCell>
        <mxCell id="a_CxjOE-Pm3qPwXydxJE-1" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;循环屏障，跟信号量的比较：&lt;br&gt;1.底层方法不同，信号量是用aqs共享锁。循环屏障是reentrylock+条件队列。&lt;br&gt;&lt;br&gt;2.循环屏障有一个资源数量的副本，用它来保证循环。&lt;br&gt;&lt;br&gt;3.循环屏障解锁步骤中，从条件队列转到等待队列中。&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1750" y="2325" width="610" height="205" as="geometry" />
        </mxCell>
        <mxCell id="u7wBqT6pgAy-At1QbIa8-1" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;读写锁：&lt;br&gt;基于AQS，那AQS只有1个state变量，怎么知道是读状态还是写状态呢？&lt;br&gt;可以用int的前16位表示读状态，后16位表示写状态？因为int有4个字节，32位。&lt;br&gt;&lt;br&gt;读写锁有一个锁降级的过程。具体是怎么的呢，为什么不能先释放写锁，再获取读锁呢？跟高并发的效率有关？&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1900" y="2620" width="720" height="190" as="geometry" />
        </mxCell>
        <mxCell id="Y7wJ-IQT0KlVhRbs83s6-1" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;阻塞队列：阻塞的是线程&lt;br&gt;生产者消费者模型：队列满了，阻塞生产者，队列空了，阻塞消费者。&lt;br&gt;各种阻塞队列的对比，以及使用场景？&lt;br&gt;&lt;br&gt;根据功能、性能等方式来选择不同的阻塞队列&lt;br&gt;&lt;br&gt;优先级队列：大小堆&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1520" y="2960" width="720" height="190" as="geometry" />
        </mxCell>
        <mxCell id="Wc7oVt73z48dbTy0IHfl-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;forkjoin框架原理？只适用于CPU密集型的任务&lt;br&gt;&lt;br&gt;分而治之，跟mapreduce有点像&lt;br&gt;&lt;br&gt;stream流式计算跟forkjoin的关系&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-660" y="-930" width="900" height="210" as="geometry" />
        </mxCell>
        <mxCell id="Wc7oVt73z48dbTy0IHfl-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;环形队列框架：Disruptor&lt;br&gt;&lt;br&gt;利用了缓存行对齐的功能。&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1480" y="-910" width="900" height="210" as="geometry" />
        </mxCell>
        <mxCell id="Wc7oVt73z48dbTy0IHfl-3" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;强弱软虚引用是什么意思？&lt;br&gt;&lt;br&gt;ThreadLocal会引起内存泄漏的原因是什么？怎么防止？&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1500" y="-1250" width="900" height="210" as="geometry" />
        </mxCell>
        <mxCell id="lDbzRusFP7WFiIEDMvLj-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;future、callable、futuretask、completedfuture的使用场景&amp;nbsp; 适合用于IO密集型的任务&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="370" y="-930" width="900" height="210" as="geometry" />
        </mxCell>
        <mxCell id="IVNExg8nK1z2wexTNMPN-1" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;java层面的线程、JVM层面的线程、操作系统层面的线程之间的关系？new&amp;nbsp; Thread().start()方法的底层怎样实现的？&lt;br&gt;&lt;br&gt;Thread对象初始化时，会调用registerNative()，进行Thread类里面的方法跟操作系统线程方法的绑定（不同操作系统的线程方法不一样。jvm屏蔽了差异，抽象出来了这些方法）。&lt;br&gt;new Thread()并不会在操作系统层面创建一个线程。而是在start()方法被调用的时候才会去创建。&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;new Thread()----&amp;gt;thread0()-----&amp;gt;JVM_StartThread()----&amp;gt;native_thread = new JavaThread()（在构造方法里面执行os::create_thread()（根据不同os创建线程，线程状态为Initialized）-----&amp;gt;sync_wait()（线程进行阻塞等待被唤醒执行thread_run()））---&amp;gt;Thread.start(native_thread)启动线程，设置状态为Runnable-----&amp;gt;os::start_thread(thread)根据不同os选择不同启动方式----&amp;gt;唤醒操作系统线程----&amp;gt;调用JavaThread::run()----&amp;gt;回调Runnable接口里面的run方法&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="650" y="-2070" width="1070" height="300" as="geometry" />
        </mxCell>
        <mxCell id="IVNExg8nK1z2wexTNMPN-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;java线程中的通信机制：&lt;br&gt;1.volatile，共享变量。&lt;br&gt;2.等待唤醒机制：wait、notify .。JUC里面的同步线程类里面，阻塞和唤醒的底层实现基本都是LockSupport的park、unpark。唤醒要注意虚假唤醒，所以要加上条件？&lt;br&gt;3.管道输入输出流。&lt;br&gt;4.Thread.join()&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;Thread.sleep、Object.wait()、LockSupport.park()的区别？&lt;br&gt;&lt;/font&gt;它们都会让线程进行休眠。wait会释放锁，其它2个不会释放锁。&lt;br&gt;使用wait的劣势：1.必须获取锁对象，只能使用在同步代码块中。2.notify只能随机选择一个线程唤醒（notifyall可以全部唤醒），不能指定一个线程。&lt;br&gt;LockSupport没有以上限制，可以随时随地使用。可以指定线程唤醒。&lt;br&gt;&lt;br&gt;&lt;span style=&quot;border-color: var(--border-color);&quot;&gt;为什么wait notify是在Object类里面的方法？&lt;/span&gt;&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;&lt;/font&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;这可能跟对象头存储的信息有关系。&lt;br&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="1800" y="-1710" width="1060" height="400" as="geometry" />
        </mxCell>
        <mxCell id="IVNExg8nK1z2wexTNMPN-3" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;LockSupport的park、unpark底层实现原理分析：&lt;br&gt;每个线程都有一个Parker实例，通过控制_counter的值来实现阻塞唤醒。park() 设置_counter为0，unpark()设置为1。类似于信号量机制&lt;br&gt;class Parker : public os::PlatformParker{&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;private :&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;volatile int _counter;&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;......&lt;br&gt;}&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="2950" y="-1700" width="1000" height="240" as="geometry" />
        </mxCell>
        <mxCell id="yG67OjCnjpooLuY3BTsW-1" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;CAS是什么？JUC包下面的哪些类用的是CAS呢？CAS跟自旋的关系？自旋的优缺点是什么？&lt;br&gt;&lt;br&gt;cas只能保证一个操作的原子性，有局限性，多个操作还得看同步锁。&lt;br&gt;&lt;br&gt;CAS的操作系统实现原理？&lt;br&gt;&lt;br&gt;ABA问题是什么，怎么解决？&lt;br&gt;&lt;br&gt;为什么说LongAddr解决了AtomicInteger的自旋瓶颈？它的原理是什么？&lt;br&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="70" y="2230" width="810" height="250" as="geometry" />
        </mxCell>
        <mxCell id="yG67OjCnjpooLuY3BTsW-2" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;locksupport跟管程模型的关系？&lt;br&gt;并没有什么卵关系。&lt;font color=&quot;#ff0000&quot;&gt;管程模型是对线程同步的一种高级抽象。&lt;br&gt;&lt;/font&gt;locksupport提供的是一种更底层的实现方式。直接使用操作系统提供的线程同步原语来实现的。&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;哪些类用到了locksupport呢？&lt;/font&gt;&lt;br&gt;ReentryLock、Semaphore、CountDownLatch、CycliBarrier、LinkedBlockingQueue、ThreadPoolExcutor等。&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;那上面这些类也用到了AQS，而AQS是java层面的管程模型，那么为什么会同时使用这2种方式呢？&lt;/font&gt;&lt;br&gt;因为AQS底层也是使用的LockSupport来实现线程的阻塞和唤醒的。管程只是一种模型，不提供线程的阻塞和唤醒具体实现方法。&lt;font color=&quot;#ff0000&quot;&gt;所以说并不是这些类直接用到了LockSupport，而是AQS用到了LockSupport。&lt;/font&gt;&lt;br&gt;&lt;br&gt;注意:并不是所有的类实现阻塞和唤醒都是通过LockSupport来实现的，还有一些其它的方式，比如synchronized，wait notify等等。&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="70" y="2510" width="840" height="300" as="geometry" />
        </mxCell>
        <mxCell id="HAI3M6Fy5APt2cnuJqtc-1" value="&lt;b style=&quot;border-color: var(--border-color); font-size: 18px;&quot;&gt;synchronized:&lt;br&gt;sync是java提供的一种原子性内置锁，也叫作监视器锁（Monitor）。&lt;br&gt;&lt;br&gt;&lt;br&gt;sync使用：可以在方法上面加（锁的是类实例），可以在代码块上面加（锁一个自己创建的对象）。&lt;br&gt;&lt;/b&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;b style=&quot;border-color: var(--border-color); font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="341" y="3360" width="660" height="340" as="geometry" />
        </mxCell>
        <mxCell id="umGzx3-XIBLnXrGLzLXI-1" value="&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;&lt;font color=&quot;#ff0000&quot;&gt;为什么需要引入JMM呢？&lt;/font&gt;&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;总所周知，JMM是一种规范，屏蔽了各类的操作系统的差异，帮助程序员更好的写多线程代码。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;其实是因为现代计算机基本上都是多核CPU了，那么硬件层面的多核CPU，在高并发下容易出现各种问题，比如缓存一致性问题。那么硬件层面为了解决这种问题，产生了一些协议或者指令（操作系统是对硬件的一些指令那些的高级抽象）。那么java为了屏蔽了各种操作系统的差异，所以引入了JMM，来规范如何访问共享变量。&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="-520" y="70" width="690" height="220" as="geometry" />
        </mxCell>
        <mxCell id="qf07nM2vf6hVkLz7YUws-1" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;&lt;font color=&quot;#3333ff&quot;&gt;管程是什么？&lt;/font&gt;&lt;br&gt;管程是一种&lt;font color=&quot;#ff0000&quot;&gt;高级（并不是操作系统或者硬件有的）&lt;/font&gt;的同步机制。用于控制多线程对共享资源的访问。管程包括了锁、条件变量、进入和退出等操作，&lt;font color=&quot;#ff3333&quot;&gt;更像是一种解决多线程访问共享变量的理论思想和概念&lt;/font&gt;。synchronized就是它的一种实现。&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#3333ff&quot;&gt;MESA模型是什么？&lt;br&gt;&lt;/font&gt;也是一种高级同步模型，强调在互斥操作之后，等待线程释放资源时要重新获取锁，而不是被唤醒后立即进入临界区，强调了一些细节的执行顺序，&lt;font color=&quot;#ff3333&quot;&gt;可以看做是管程的一种实现方式。&lt;br&gt;&lt;/font&gt;&lt;br&gt;管程中，线程等待被唤醒之后会立即进入临界区，例如sync。MESA不会立即进入，需要重新获取锁，例如 ReentryLock。&lt;br&gt;&lt;br&gt;sync和Object类的wait()、notify()方法是基于Monitro机制实现的。&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;align=left;" parent="1" vertex="1">
          <mxGeometry x="-360" y="3360" width="660" height="340" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
