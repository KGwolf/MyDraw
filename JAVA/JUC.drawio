<mxfile host="app.diagrams.net" modified="2023-09-02T09:10:50.572Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62" etag="hCucEBlVjyMv10frzuJi" version="21.7.2" type="github">
  <diagram name="第 1 页" id="oAc0U7i2WO9zVuW95_pL">
    <mxGraphModel dx="2209" dy="759" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-1" value="&lt;b style=&quot;border-color: var(--border-color); font-size: 18px;&quot;&gt;volatile为什么只能保证可见性和有序性，不能保证原子性？&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;volatile实现可见性和有序性的原理是加了内存屏障。&lt;/b&gt;" style="rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;" vertex="1" parent="1">
          <mxGeometry x="-360" y="460" width="690" height="170" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-2" value="&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;并发编程的三大特性：可见性、有序性、原子性。&lt;br&gt;&lt;br&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=center;verticalAlign=middle;" vertex="1" parent="1">
          <mxGeometry x="-350" y="40" width="1220" height="70" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-3" value="&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;font-size: 18px; background-color: initial;&quot;&gt;那什么是可见性呢？&lt;/b&gt;&lt;/div&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;这就要从JMM模型说起了，那JMM是什么呢？&lt;/b&gt;&lt;/div&gt;&lt;b&gt;&lt;div style=&quot;&quot;&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;JMM：java memory model，java内存模型。&lt;font color=&quot;#ff3333&quot;&gt;它屏蔽了各种操作系统的内存访问差异，规范了多线程程序访问内存的方式（规定了一个线程如何何时可以看到由其它线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。）&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;/b&gt;&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" vertex="1" parent="1">
          <mxGeometry x="-390" y="170" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-4" value="&lt;b style=&quot;&quot;&gt;&lt;font style=&quot;font-size: 18px;&quot;&gt;在多核CPU中，JMM规定了怎么访问共享内存，首先在主存里面存在一个共享数据且线程A和线程B由不同的CPU内核执行。那JVM中规定了每个线程都有自己的线程栈，相当于是&lt;font style=&quot;&quot; color=&quot;#ff3333&quot;&gt;每个线程都有自己的独有内存，都程会单独拷贝主存里面的数据&lt;/font&gt;。那么&lt;font style=&quot;&quot; color=&quot;#ff3333&quot;&gt;这种模型，可能就会导致一个线程修改了共享变量的值之后，对另外一个线程不可见。&lt;/font&gt;这就是可见性。&lt;/font&gt;&lt;/b&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" vertex="1" parent="1">
          <mxGeometry x="360" y="170" width="670" height="150" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-5" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;那其实JMM跟硬件CPU读取内存变量其实是有差异的。&lt;br&gt;硬件可能也会有缓存一致性的问题。那么硬件的工作模型是：主存存放所有的计算数据。多核CPU的情况，每个CPU核心都会有自己的一二级缓存，有的计算机也会有共享的三级缓存。那么CPU会将主存中的数据，读取到自己的一二级缓存中去。这样也可能会有修改了数据，其它核心不可见。&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" vertex="1" parent="1">
          <mxGeometry x="1070" y="170" width="680" height="160" as="geometry" />
        </mxCell>
        <mxCell id="rkv5G4KE9S5kMJV3ECuV-6" value="&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;b&gt;那么硬件上怎么处理这种缓存不一致的问题呢？有各种针对不同CPU架构的协议，比如MESI协议，MESI的原理是什么呢？&lt;br&gt;&lt;br&gt;那么硬件的缓存一致性协议跟JMM规定的内存访问方式的区别是什么呢？&lt;br&gt;&lt;/b&gt;&lt;/span&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;" vertex="1" parent="1">
          <mxGeometry x="1801" y="170" width="680" height="160" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
